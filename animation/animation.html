<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js" integrity="sha256-Xb6SSzhH3wEPC4Vy3W70Lqh9Y3Du/3KxPqI2JHQSpTw=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-transform/1.0.4/d3-transform.min.js" integrity="sha256-6lfvvQQRGR9XoF57Y/3H37BZCHaP6BvLihL9k/jHVhI=" crossorigin="anonymous"></script>
        <!-- <link href="https://fonts.googleapis.com/css2?family=EB+Garamond&display=swap" rel="stylesheet"> -->
        <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;1,400;1,500&display=swap" rel="stylesheet">
        <style>
.pausaIndicatorText {
    color: yellow;
    font-size: 1400%;
    text-shadow: 0px 8px 10px #000, 0px -8px 10px #000, 5px 5px 10px #000, -5px 5px 10px #000, 5px -5px 10px #000, -5px -5px 10px #000;
}

.waveSlow {
    animation: waveSmall 0.6s alternate infinite ease-in-out;
}

.waveFast {
    animation: waveLarge 0.3s alternate infinite ease-in-out;
}

@keyframes waveSmall {
    from { transform: translateX(-8px); }
    to { transform: translateX(8px); }
}

@keyframes waveLarge {
    from { transform: translateX(-15px); }
    to { transform: translateX(15px); }
}
        </style>
    </head>
    <body style="background-color: #444">
        <svg width="1920" height="1080" style="background-color: darkgray; margin: 20px">
            <defs>
                <filter id="dropShadow" x="-10%" y="-10%" width="150%" height="150%">
                    <feOffset result="offOut" in="SourceGraphic" dx="20" dy="20"/>
                    <feGaussianBlur result="blurOut" in="offOut" stdDeviation="20"/>
                    <feBlend in="SourceGraphic" in2="blurOut" mode="normal"/>
                </filter>
            </defs>
        </svg>
        <video id="gameClip" style="opacity: 0; position: absolute; top: 0px; left: 0px; z-index: 5;" width="1440" height="810">
            <source src="game_clip_lowres.mp4" type="video/mp4">
        </video>
        <div id="pausaIndicatorContainer" style="opacity: 0; position: absolute; top: 0px; left: 0px; z-index: 10; width: 1440px; height: 810px; padding: 0px;">
            <div id="pausaIndicatorFloat" style="float: right; margin: 40px; margin-top: 20px;">
                <!-- ⏸⏵⏩️ -->
                <span id="pausaIndicator" class="pausaIndicatorText">⏸</span>
            </div>
        </div>
        <pre id="messageBox" style="color: white; font-size: 200%; margin: 20px; margin-left: 60px;"></pre>
        <pre id="errorBox" style="color: white; font-size: 200%; margin: 20px; margin-left: 60px;"></pre>
        <script>

let globalTimeScale = 0.05;
var skipThrough = true;

//globalTimeScale = 1.0;
//skipThrough = false;

function sleep(ms) {
    /*
    let err = new Error();
    let msg = err.stack.split(/\n/).slice(2, 3).join("\n");
    let box = document.getElementById("errorBox");
    box.innerText = msg + "\n" + box.innerText;
    */
    return new Promise(resolve => setTimeout(resolve, ms * globalTimeScale));
}

const svg = d3.select("svg");

const _transition = d3.transition();
const closedDuration = _transition.__proto__.duration;
_transition.__proto__.duration = function(...args) {
    if (args.length >= 1)
        args[0] *= globalTimeScale;
    return closedDuration.call(this, ...args);
};

function wrapGroup(o) {
    const g = svg.append("g");
    g.append(o);
    return g;
}

// Define an arrow head.
svg.append("defs").append("marker")
    .attr("id", "arrowHead")
    .attr("refX", 10)
    .attr("refY", 10)
    .attr("markerWidth", 20)
    .attr("markerHeight", 20)
    .attr("orient", "auto")
    .append("path")
    .attr("d", "M 10 10 l -2 -4 c 4 3 6 3.5 10 4 c -4 0.5 -6 1 -10 4 Z")
    .attr("stroke", "black")
    .attr("fill", "none")
    .attr("stroke-linejoin", "round")
    .attr("stroke-width", 1);

function fadeIn(g) {
    return g.transition()
        .duration(500)
        .attr("opacity", 1);
}

function makeLine(x1, y1, x2, y2, root) {
    if (root === undefined)
        root = svg;
    const g = root.append("g");

    g.append("line")
        .attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2)
        .attr("stroke-width", 2).attr("stroke", "black").attr("stroke-linecap", "round");
    const anim = g.selectAll("line")
        .transition()
        .duration(1000)
        .attr("stroke-width", 5);

    return [g, anim];
}

function makeExtendoLine(x1, y1, x2, y2, root) {
    const [line, anim] = makeLine(x1, y1, x1, y1, root);
    anim.attr("x2", x2).attr("y2", y2);
    return [line, anim];
}

function makeExtendoArrow(x1, y1, x2, y2, root) {
    const [line, anim] = makeExtendoLine(x1, y1, x2, y2, root);
    line.attr("marker-end", "url(#arrowHead)");
    return [line, anim];
}

const S = 40;

const colorMap = d3.scaleLinear()
    .domain([0/6, 1/6, 2/6, 3/6, 4/6, 5/6, 6/6])
    .range(['#004', '#070', '#090', '#0b0', '#0c0', '#0d0', '#3d3'])
    //.domain([0, 0.5, 1])
    //.range(['#004', '#0a0', '#0c0'])
    .interpolate(d3.interpolateRgb); //.interpolate(d3.interpolateHcl);

function setBoardProbabilities(board, probCallback, tweenNumbers, timeScale) {
    timeScale = timeScale === undefined ? 1 : timeScale;
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            const prob = probCallback(x, y);
            if (prob === 'transparent') {
                board.grid[[x, y]].transition()
                    .duration(1000 * timeScale)
                    .attr("opacity", 0);
            } else {
                const color = colorMap(prob);
                board.grid[[x, y]].transition()
                    .duration(1000 * timeScale)
                    .attr("opacity", 1)
                    .attr("fill", color);
            }

            if (tweenNumbers) {
                const oldValue = board.valueGrid[[x, y]];
                board.valueGrid[[x, y]] = prob;
                board.textGrid[[x, y]].transition()
                    //.duration(400 + (x + y) * 35)
                    //.transition()
                    //.duration(0)
                    .duration(1000 * timeScale)
                    .textTween(() => t => (100 * ((1 - t) * oldValue + t * prob)).toFixed(0));
                    //.text((100 * prob).toFixed(0));
                //board.textGrid[[x, y]].text((100 * prob).toFixed(0));
            }
        }
    }
}

function squidsToCellColors(squids) {
    const cellColors = {};
    for (let y = 0; y < 8; y++)
        for (let x = 0; x < 8; x++)
            cellColors[[x, y]] = colorMap(0.0);

    const lengthToColor = {2: "red", 3: "green", 4: "blue"};
    let squidLength = 2;
    for (const squid of squids) {
        let {x, y} = squid;
        for (let i = 0; i < squidLength; i++) {
            cellColors[[x, y]] = lengthToColor[squidLength];
            if (squid.horizontal)
                x++;
            else
                y++;
        }
        squidLength++;
    }

    return cellColors;
}

function setBoardSquids(board, squids) {
    const cellColors = squidsToCellColors(squids);
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            board.grid[[x, y]].transition()
                .duration(600)
                .attr("fill", cellColors[[x, y]]);
        }
    }
    board.cellColors = cellColors;
}

async function makeBoard(centerX, centerY, scale, root, timeScale, hideProbs, squids, skipGlow) {
    timeScale = timeScale === undefined ? 1 : timeScale;
    hideProbs = hideProbs === undefined ? false : hideProbs;
    const cellColors = squids === undefined ? null : squidsToCellColors(squids);
    skipGlow = skipGlow === undefined ? false : skipGlow;

    root = root.append("g");
    if (!skipGlow)
        root.attr("filter", "url(#dropShadow)");
    root.attr("transform", d3Transform()
        .translate([centerX, centerY])
        .translate(-S * 4, -S * 4)
        .scale(scale)
    );

    // ['#004', '#070', '#090', '#0b0', '#0d0', '#0f0', '#6f6']
    const grid = {};
    const textGrid = {};
    const valueGrid = {};
    for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
            const rect = root.append("rect");
            rect.attr("width", S).attr("height", S)
                .attr("fill", cellColors === null ? "#004" : cellColors[[x, y]])
                .attr("transform", d3Transform()
                    .translate(x * S, y * S)
                );
            rect.attr("opacity", 0);
            rect.transition()
                .duration((600 + (x + y) * 35) * timeScale)
                .transition()
                .duration(1000 * timeScale)
                .attr("opacity", 1);
            grid[[x, y]] = rect;

            const text = root.append("text");
            text.text(hideProbs ? "" : "0")
                .attr("x", 0).attr("y", 0)
                .attr("font-family", "EB Garamond")
                .attr("font-size", "15px")
                .attr("font-style", "italic")
                .attr("stroke", "white")
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "middle")
                .attr("transform", d3Transform()
                    .translate([x * S + S / 2, y * S + S / 2])
                );
            text.attr("opacity", 0);
            text.transition()
                .duration((200 + (x + y) * 35) * timeScale)
                .transition()
                .duration(1000 * timeScale)
                .attr("opacity", 1);
            textGrid[[x, y]] = text;
            valueGrid[[x, y]] = 0;
        }
    }

    for (let i = 0; i < 9; i++) {
        const hrule = root.append("line")
            .attr("x1", 0).attr("y1", S * i).attr("x2", 0).attr("y2", S * i)
            .attr("stroke-width", 1).attr("stroke", "lightgray").attr("stroke-linecap", "round");
        hrule.transition()
            .duration(800 * timeScale)
            .ease(d3.easeLinear)
            .attr("x2", 8 * S)
            .attr("opacity", 1)
            .attr("stroke-width", 3);
        const vrule = root.append("line")
            .attr("x1", S * i).attr("y1", 0).attr("x2", S * i).attr("y2", 0)
            .attr("stroke-width", 1).attr("stroke", "lightgray").attr("stroke-linecap", "round");
        vrule.transition()
            .duration(800 * timeScale)
            .ease(d3.easeLinear)
            .attr("y2", 8 * S)
            .attr("opacity", 1)
            .attr("stroke-width", 3);
        await sleep(35 * timeScale);
    }

    return {root, grid, textGrid, valueGrid, cellColors};
}

// Idea: Show the histogram of actual board likelihoods.

// Generate the Wichmann-Hill sequences.
let x = 100, y = 100, z = 100;
const rngSeq = [];
for (let i = 0; i < 100; i++) {
    x = (x * 171) % 30269;
    y = (y * 172) % 30307;
    z = (z * 170) % 30323;
    const r = (x/30269 + y/30307 + z/30323) % 1.0;
    rngSeq.push(r);
}

function getBigBoiCurlyTransforms(x, y, yScale, rotation) {
    let translation = [x + 25, y + 18 - 7 * yScale];
    if (rotation == -90)
        translation = [x - 6 * yScale, y - 40];
    return {
        bracket: d3Transform()
            .translate([x, y])
            .rotate(rotation)
            .scale(2, yScale),
        t: d3Transform().translate(translation),
    };
}

function makeBigBoiCurly(textGroup, x, y, yScale, label, rotation) {
    rotation = rotation === undefined ? 0 : rotation;
    const parent = textGroup.append("g");
    const bracket = parent.append("text");
    const transforms = getBigBoiCurlyTransforms(x, y, yScale, rotation);
    bracket.text("}")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "90px")
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .attr("transform", transforms.bracket);
    
    const t = parent.append("text");
    t.text(label)
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "60px")
        .attr("font-style", "italic")
        .attr("transform", transforms.t);
    if (rotation == -90)
        t.attr("text-anchor", "middle");
    parent.selectAll("text").transition()
        .duration(1000)
        .attr("fill-opacity", 1);
    return {parent, bracket, t};
}

async function showRNGSequence(root) {
    // Whoops, I decided I want to shift everything over...
    root = root.append("g");
    root.attr("transform", d3Transform().translate([100, 0]));

    // Make the RNG table.
    await sleep(250);
    const tableGroup = root.append("g");
    fadeIn(makeExtendoLine(-30, 0, 1000, 0, tableGroup)[0]);
    fadeIn(makeExtendoLine(300, -80, 300, 850, tableGroup)[0]);
    fadeIn(makeExtendoLine(660, -80, 660, 850, tableGroup)[0]);
    tableGroup.attr("transform", d3Transform().translate([100, 150]));

    await sleep(250);
    const textGroup = tableGroup.append("g");
    textGroup.append("text").text("RNG step #")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "60px")
        .attr("font-style", "italic")
        .attr("transform", d3Transform()
            .translate([0, -30])
        );
    textGroup.append("text").text("RNG output")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "60px")
        .attr("font-style", "italic")
        .attr("transform", d3Transform()
            .translate([330, -30])
        );
    textGroup.append("text").text("Use")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "60px")
        .attr("font-style", "italic")
        .attr("transform", d3Transform()
            .translate([690, -30])
        );
    textGroup.selectAll("text").transition()
        .duration(1000)
        .attr("fill-opacity", 1);

    //await sleep(1000);
    await nextSlide();
    const uses = [];
    function fillInRow(rowIndex, texts) {
        let xOffsets = [0 + 100, 340, 690];
        if (rowIndex == 10)
            xOffsets = [0 + 85, 340 + 110, 690 + 30];
        for (let i = 0; i < texts.length; i++) {
            const text = textGroup.append("text");
            text.text(texts[i])
                .attr("x", 0).attr("y", 0)
                .attr("font-family", "EB Garamond")
                .attr("font-size", "60px")
                .attr("transform", d3Transform()
                    .translate([xOffsets[i], 60 + 75 * rowIndex])
                );
            //if (i == 0)
            //    text.attr("text-anchor", "right");
            if (rowIndex !== 10)
                text.attr("font-style", "italic");
            if (i == 2)
                uses.push(text);
        }
        textGroup.selectAll("text").transition()
            .duration(600)
            .attr("fill-opacity", 1);
    }
    for (let i = 0; i < 10; i++) {
        fillInRow(i, [i, rngSeq[i].toFixed(8), ""]);
        if (i == 0) {
            //await sleep(1000);
            await nextSlide();
        }
        await sleep(300);
    }
    fillInRow(10, ["⋮", "⋮", ""])

    //await sleep(1000);
    await nextSlide();
    for (const use of uses.slice(0, -1)) {
        use.attr("fill-opacity", 0);
        use.text("???");
        use.transition()
            .duration(600)
            .attr("fill-opacity", 1);
        await sleep(200);
    }

    // Draw a big curly brace.
    async function textFillLoop(offset, useTexts) {
        for (let i = 0; i < useTexts.length; i++) {
            uses[i + offset].transition()
                .duration(300)
                .attr("fill-opacity", 0)

                .transition()
                .duration(0)
                .text(useTexts[i])

                .transition()
                .duration(300)
                .attr("fill-opacity", 1);
            await sleep(200);
        }
    }

    //await sleep(3000);
    await nextSlide();
    makeBigBoiCurly(textGroup, 1250, 180, 3.5, "Frame #1");
    textFillLoop(0, ["Should Link blink?", "Should a rupee sparkle?", "Particle effect velocity"]);

    //await sleep(3000);
    await nextSlide();
    makeBigBoiCurly(textGroup, 1250, 480, 3.5, "Frame #2");
    textFillLoop(4, ["Should Link blink?", "Should a rupee sparkle?", "Particle effect velocity", "Object lighting"]);

    //await sleep(2000);
    await nextSlide();
    makeBigBoiCurly(textGroup, 1250, 780, 3.5, "Frame #3");
    textFillLoop(8, ["Should Link blink?", "Should a rupee sparkle?", "⋮"]);
    //await sleep(2000);
    await nextSlide();
}

// From: https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
var mulberry32State = 123456789;
function RNG() {
    var t = mulberry32State += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
}

// Make some random board layouts.
function makeSquidLayout() {
    const squidDescs = [];
    for (let y = 0; y < 8; y++)
        for (let x = 0; x < 8; x++)
            for (const horizontal of [false, true])
                squidDescs.push({x, y, horizontal});
    let alreadyHit = {};
    const layout = [];
    for (const length of [2, 3, 4]) {
        let newAlreadyHit;
        rejection_sampling:
        while (true) {
            const desc = squidDescs[Math.floor(RNG() * squidDescs.length)];
            let {x, y} = desc;
            newAlreadyHit = {...alreadyHit};
            for (let i = 0; i < length; i++) {
                if (alreadyHit[[x, y]] || x > 7 || y > 7)
                    continue rejection_sampling;
                newAlreadyHit[[x, y]] = true;
                if (desc.horizontal)
                    x++;
                else
                    y++;
            }
            alreadyHit = newAlreadyHit;
            layout.push(desc);
            break;
        }
    }
    return layout;
}

const exampleSquidLayouts = [];
for (let i = 0; i < 1000; i++)
    exampleSquidLayouts.push(makeSquidLayout());

async function drawHit(root, x, y, scale, color) {
    const parent = root.append("g");

    const angle = i => 2 * Math.PI * (i / 16);
    const pathFunction = d3.line()
        .x((d, i) => d * Math.cos(angle(i)))
        .y((d, i) => d * Math.sin(angle(i)))
        .curve(d3.curveLinear);

    const distances = [];
    for (let i = 0; i < 4; i++)
        distances.push(1, 0.5, 1.0, 0.5);
    distances.push(1); // Ugh, there must be a d3 option to close the path. :/

    parent.append("path")
        .attr("d", pathFunction(distances))
        .attr("stroke", "#c00")
        .attr("fill", "orange")
        .attr("stroke-linejoin", "round")
        .attr("stroke-width", 0.15);

    parent.attr("transform", d3Transform()
        .translate([x, y])
        .scale(0));

    parent.transition()
        .duration(600)
        .attr("opactiy", 1)
        .attr("transform", d3Transform()
            .translate([x, y])
            .scale(scale));
    return parent;
}

function drawX(root, x, y, scale, color) {
    const parent = root.append("g");
    const backSlashUnder = parent.append("line")
        .attr("x1", -1).attr("y1", -1).attr("x2", -1).attr("y2", -1)
        .attr("stroke-width", 0.5).attr("stroke", "black").attr("stroke-linecap", "round");
    backSlashUnder.transition()
        .duration(500)
        .attr("x2", 1)
        .attr("y2", 1);

    const slashUnder = parent.append("line")
        .attr("x1", 1).attr("y1", -1).attr("x2", 1).attr("y2", -1)
        .attr("stroke-width", 0.5).attr("stroke", "black").attr("stroke-linecap", "round");
    slashUnder.attr("opacity", 0);
    slashUnder.transition()
        .duration(500)
        .transition()
        .duration(0)
        .attr("opacity", 1)
        .transition()
        .duration(250)
        .attr("x2", -1)
        .attr("y2", 1);

    const backSlashOver = parent.append("line")
        .attr("x1", -1).attr("y1", -1).attr("x2", -1).attr("y2", -1)
        .attr("stroke-width", 0.3).attr("stroke", color).attr("stroke-linecap", "round");
    backSlashOver.transition()
        .duration(500)
        .attr("x2", 1)
        .attr("y2", 1);

    const slashOver = parent.append("line")
        .attr("x1", 1).attr("y1", -1).attr("x2", 1).attr("y2", -1)
        .attr("stroke-width", 0.3).attr("stroke", color).attr("stroke-linecap", "round");
    slashOver.attr("opacity", 0);
    slashOver.transition()
        .duration(500)
        .transition()
        .duration(0)
        .attr("opacity", 1)
        .transition()
        .duration(250)
        .attr("x2", -1)
        .attr("y2", 1);

    parent.attr("transform", d3Transform()
        .translate([x, y])
        .scale(scale));
    return parent;
}

async function drawHighlightCircle(root, x, y, scale, color) {
    const parent = root.append("g");
    const circ = parent.append("circle");
    circ.attr("cx", 0).attr("cy", 0).attr("r", 1.0);
    circ.attr("stroke-width", 0.3).attr("stroke", color).attr("fill", "none");
    t = circ.transition()
        .duration(500)
        .attr("opacity", 1)
        .attr("r", 1.5);
    for (let i = 0; i < 2; i++)
        t = t.transition()
            .duration(500)
            .attr("r", 1.0)
            .transition()
            .duration(500)
            .attr("r", 1.5);
    t.attr("opacity", 0);
    parent.attr("transform", d3Transform()
        .translate([x, y])
        .scale(scale));
    return parent;
}

async function showBoardAveraging(root) {
    await sleep(250);

    const board = await makeBoard(800, 350, 2, root, 1, true); // Good

    await nextSlide();
    setBoardSquids(board, exampleSquidLayouts[0]);

    await nextSlide();
    setBoardSquids(board, exampleSquidLayouts[1]);

    await nextSlide();
    setBoardSquids(board, exampleSquidLayouts[2]);

    await nextSlide();
    board.root.transition()
        .duration(1000).attr("transform", d3Transform()
            .translate([1100, 100])
            .scale(0.6));

    const boards = [board];
    for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 3; x++) {
            if (x == 0 && y == 0)
                continue
            async function makeThisParticularBoard(x, y) {
                const b = await makeBoard(1260 + 220 * x, 260 + 220 * y, 0.6, root, 0.4, true, exampleSquidLayouts[2 + x + y * 3]);
                //b.root.attr("transform", d3Transform()
                    //.translate([1100 + 220 * x, 100 + 220 * y])
                    //.scale(0.6));
                // I guess there's probably technically a race here,
                // on this push. I don't particularly care.
                boards.push(b);
            }
            makeThisParticularBoard(x, y);
            await sleep(100);
        }
    }

    await nextSlide();
    const aggregationBoard = await makeBoard(400, 350, 2, root, 0.6);

    await nextSlide();
    for (const board of boards) {
        setBoardProbabilities(board, (x, y) => {
            return board.cellColors[[x, y]] === 'rgb(0, 0, 68)' ? 0 : 1;
        }, false);
        await sleep(200);
    }

    // Slide overlays of all of the boards onto the main board.
    await nextSlide();
    for (const board of boards)
        board.filteredOut = false;

    async function animateProbabComputation(slowFirstBoard) {
        const overlays = [];
        const overlayCells = [];
        let boardCounter = 0;
        for (const board of boards) {
            if (board.filteredOut)
                continue;
            boardCounter++;
            const timeScale = boardCounter <= 3 && slowFirstBoard ? 0.7 : Math.max(0.15, 0.5 - 0.08 * (boardCounter - 3));

            const cloneRaw = board.root.node().cloneNode(true);
            root.node().appendChild(cloneRaw);
            const clone = d3.select(cloneRaw);
            clone.attr("filter", "");
            clone.attr("opacity", 0.9);
            clone.transition()
                .duration(3000 * timeScale)
                .attr("transform", d3Transform()
                    .translate([400, 350])
                    .translate(-S * 4, -S * 4)
                    .scale(2))
                .attr("opacity", 0.8)
                .transition()
                .duration(500 * timeScale)
                .attr("opacity", 0.0);
            clone.selectAll("rect").each(function() {
                rect = d3.select(this);
                rect.attr("fill-opacity", 1);
                if (rect.attr("fill") === "rgb(0, 0, 68)") {
                    rect.transition()
                        .duration(1000 * timeScale)
                        .transition()
                        .duration(2000 * timeScale)
                        .attr("fill-opacity", 0);
                } else {
                    rect.transition()
                        .duration(2500 * timeScale)
                        .transition()
                        .duration(1000 * timeScale)
                        .attr("fill-opacity", 0);
                }
            });
            clone.selectAll("line").each(function() {
                line = d3.select(this);
                line.attr("stroke-opacity", 1);
                line.transition()
                    .duration(5000 * timeScale)
                    .attr("stroke-opacity", 0.5);
            });
            overlays.push(clone);
            overlayCells.push(board.cellColors);

            await sleep(2200 * timeScale);
            setBoardProbabilities(aggregationBoard, (x, y) => {
                let accum = 0;
                for (const cellColors of overlayCells)
                    accum += cellColors[[x, y]] === 'rgb(0, 0, 68)' ? 0 : 1;
                return accum / overlayCells.length;
            }, true, timeScale);

            await sleep(1500 * timeScale);
            //await nextSlide();
        }
    }
    await animateProbabComputation(true);

    // Draw an indicator on the highest probability cell.
    await nextSlide();
    drawHighlightCircle(root, 520, 470, 30, "yellow");

    // Draw a miss.
    await nextSlide();
    drawX(root, 520, 470, 30, "white");

    // X out the incompatible boards.
    await nextSlide();
    async function filterOutIncompatible(shootX, shootY, hit) {
        let boardIndex = -1;
        for (const board of boards) {
            boardIndex++;
            if (board.filteredOut)
                continue;
            const hitStatus = board.cellColors[[shootX, shootY]] !== 'rgb(0, 0, 68)';
            if (hitStatus !== hit) {
                x = boardIndex % 3;
                y = Math.floor(boardIndex / 3);
                drawX(root, 1100 + S*4 * 0.6 + 220 * x, 100 + S*4 * 0.6 + 220 * y, 70, "red");
                await sleep(200);
                board.filteredOut = true;
                board.root.attr("opacity", 1);
                board.root.transition()
                    .duration(1000)
                    .attr("opacity", 0.4);
            }
        }
    }
    await filterOutIncompatible(3, 3, false);

    // Recompute the probabilities.
    await nextSlide();
    setBoardProbabilities(aggregationBoard, (x, y) => {
        return 0;
    }, true, 1);
    await sleep(2000);
    await animateProbabComputation(false);

    // Draw an indicator on the highest probability cell.
    await nextSlide();
    drawHighlightCircle(root, 520 - S*2, 470 - S*2, 30, "yellow");


    // Draw a hit.
    await nextSlide();
    drawHit(root, 520 - S*2, 470 - S*2, 45);

    // Filter out boards without a hit.
    await nextSlide();
    await filterOutIncompatible(2, 2, true);

    // Recompute the probabilities.
    await nextSlide();
    globalTimeScale *= 0.5;
    setBoardProbabilities(aggregationBoard, (x, y) => {
        return 0;
    }, true, 1);
    await sleep(2000);
    await animateProbabComputation(false);
    globalTimeScale *= 2;


    // Draw a hit.
    await nextSlide();
    drawHit(root, 520 - S*2, 470, 45);

    // Filter out boards without a hit.
    await nextSlide();
    await filterOutIncompatible(2, 3, true);
    // Recompute the probabilities.
    await sleep(1000);
    globalTimeScale *= 0.5;
    setBoardProbabilities(aggregationBoard, (x, y) => {
        return 0;
    }, true, 1);
    await sleep(2000);
    await animateProbabComputation(false);
    globalTimeScale *= 2;

    // Draw a miss.
    await nextSlide();
    drawX(root, 520 - 2 * S*2, 470, 30, "white");
    // Filter out boards with a hit.
    await sleep(1000);
    await filterOutIncompatible(1, 3, false);
    // Recompute the probabilities.
    await sleep(1000);
    globalTimeScale *= 0.5;
    setBoardProbabilities(aggregationBoard, (x, y) => {
        return 0;
    }, true, 1);
    await sleep(2000);
    await animateProbabComputation(false);
    globalTimeScale *= 2;

    // Fill in the remaining hits.
    await nextSlide();
    for (const [x, y] of [
        [4, 4], [4, 5], [4, 6],
        [5, 3], [5, 4], [5, 5], [5, 6],
    ]) {
        drawHit(root, 280 + x * S*2, 230 + y * S*2, 45);
        await sleep(100);
    }

    await nextSlide();
}

async function showBoardSequence(root) {
    // Draw a board.
    await sleep(250);

    const board = await makeBoard(800, 350, 2, root, 1, true);

    // Shift the board over to the left.
    //await sleep(1500);
    await nextSlide();
    board.root.transition()
        .duration(1000)
        .attr("transform", d3Transform().translate([100, 350]));

    // Start making new boards.
    await sleep(1500);
    //await nextSlide();
    for (let i = 0; i < 3; i++) {
        const board = await makeBoard(260 + (i + 1) * 380, 510, 1, root, 1, true);
        //board.root.attr("transform", d3Transform().translate([100 + (i + 1) * 380, 350]));
        await sleep(200);
    }
    // Make an ellipsis.
    const ellipsis = root.append("g");
    ellipsis.attr("transform", d3Transform().translate([120 + 4 * 380, 350 + S * 4]));
    for (let i = 0; i < 3; i++) {
        const circle = ellipsis.append("circle");
        circle.attr("cx", i * 50).attr("cy", 0).attr("r", 8)
            .attr("fill", "white").attr("fill-opacity", 0);
        circle.transition()
            .duration(500 + 120 * i)
            .transition()
            .duration(800)
            .attr("fill-opacity", 1);
    }

    //await sleep(2000);
    await nextSlide();
    ellipsis.selectAll("circle")
        .transition()
        .duration(1000)
        .attr("fill-opacity", 0);
    //svg.selectAll(ellipsis).remove();

    /*
    while (true) {
        await sleep(2000);
        setBoardProbabilities(board, (x, y) => {
            return Math.random() * Math.random();
        });
    }
    //*/

    return;
}

// Note for accuracy:
// The RNG steps: [13, 26, 42, 52, 58] ...
// ... give the boards: [524129, 575982, 387644, 492053, 451312]

async function showBoardSampling(root) {
    // Make the axis arrows pop in.
    await sleep(250);
    const axisGroup = root.append("g");
    fadeIn(makeExtendoArrow(0, 0, 1750, 0, axisGroup)[0]);
    //axisGroup.attr("transform", d3Transform().translate([60, 950]));
    axisGroup.attr("transform", d3Transform().translate([60, 200]));

    // Make little tick marks appear.
    await sleep(1000);
    const ticksGroup = axisGroup.append("g");
    for (let i = 0; i < 87; i++) {
        await sleep(10);

        const x = 10 + 20 * i

        const tick = ticksGroup.append("line")
            .attr("x1", x).attr("y1", 0).attr("x2", x).attr("y2", 0)
            .attr("stroke-width", 0).attr("stroke", "black").attr("stroke-linecap", "round")
            .attr("fill", "none");
        if (i % 5 == 0) {
            tick.transition()
                .duration(500)
                .attr("stroke-width", 3)
                .attr("y2", 20);
            const t = axisGroup.append("text");
            t.text("" + i)
                .attr("x", 0).attr("y", 0)
                .attr("font-family", "EB Garamond")
                .attr("font-size", "40px")
                .attr("font-style", "italic")
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "middle")
                .attr("transform", d3Transform()
                    .translate([x, 50])
                );
            t.transition()
                .duration(1000)
                .attr("fill-opacity", 1);
        } else {
            tick.transition()
                .duration(500)
                .attr("stroke-width", 2)
                .attr("y2", 15);
        }
    }

    //await sleep(1000);
    await nextSlide();
    makeBigBoiCurly(axisGroup, 162, -35, 3.3, "Frame #1", -90);

    // Show the board.
    //await sleep(1000);
    await nextSlide();
    const indicatorPath = axisGroup.append("path");
    const pathFunction = d3.line()
        .x(function(d, i) { return 20 * d + 12; })
        .y(function(d, i) { return +75 * i + 10; })
        .curve(d3.curveBasis);
    let pathData = [13, 15, 38 - 1.5, 40 - 1.5];
    indicatorPath.attr("d", pathFunction(pathData))
        .attr("stroke-width", 8).attr("stroke", "black").attr("stroke-linecap", "round")
        .attr("fill", "none").attr("marker-end", "url(#arrowHead)");
    indicatorPath.transition()
        .duration(1000)
        .attr("opacity", 1);

    const board = await makeBoard(20 * 40 + 12 - 80, 550 - 80, 1.5, axisGroup, 1, true);
    await sleep(1500); // XXX: This value must wait for the board to fully color!
    setBoardSquids(board, [
        {x: 3, y: 6, horizontal: true},
        {x: 6, y: 4, horizontal: false},
        {x: 1, y: 2, horizontal: true},
    ]);
    await nextSlide();
    const genParent = axisGroup.append("g");
    makeBigBoiCurly(genParent, 162 + 62, -35, 4.6, "Board gen", -90);
    genParent.attr("transform", d3Transform().translate([20 * 13, 0]));

    //await sleep(1000);
    await nextSlide();
    makeBigBoiCurly(axisGroup, 162 + 20 * 13, -35, 3.3, "Frame #2", -90);
    pathData = [26, 28, 38 - 1.5, 40 - 1.5];
    indicatorPath.transition()
        .duration(1000)
        .attr("d", pathFunction(pathData));
    genParent.transition()
        .duration(1000)
        .attr("transform", d3Transform()
            .translate([20 * 26, 0])
        );
    setBoardSquids(board, [
        {x: 2, y: 7, horizontal: true},
        {x: 0, y: 0, horizontal: false},
        {x: 3, y: 0, horizontal: false},
    ]);

    //await sleep(1000);
    await nextSlide();
    makeBigBoiCurly(axisGroup, 162 + 20 * 28 - 2, -35, 4.1, "Frame #3", -90);
    pathData = [42, 41, 41 + 0.5, 40 + 0.5];
    indicatorPath.transition()
        .duration(1000)
        .attr("d", pathFunction(pathData));
    genParent.transition()
        .duration(1000)
        .attr("transform", d3Transform()
            .translate([20 * 42, 0])
        );
    setBoardSquids(board, [
        {x: 6, y: 4, horizontal: false},
        {x: 0, y: 3, horizontal: false},
        {x: 1, y: 4, horizontal: false},
    ]);

    //await sleep(1000);
    await nextSlide();
    const frame4 = makeBigBoiCurly(axisGroup, 162 + 20 * 40 + 8, -35, 2.55, "Frame #4", -90);
    pathData = [52, 50, 42 + 1.5, 40 + 1.5];
    indicatorPath.transition()
        .duration(1000)
        .attr("d", pathFunction(pathData));
    genParent.transition()
        .duration(1000)
        .attr("transform", d3Transform()
            .translate([20 * 52, 0])
        );

    setBoardSquids(board, [
        {x: 0, y: 6, horizontal: true},
        {x: 4, y: 5, horizontal: true},
        {x: 5, y: 1, horizontal: false},
    ]);

    // Show how a frame can be variable.
    //await sleep(1000);
    await nextSlide();
    const newFrame4Transforms = getBigBoiCurlyTransforms(162 + 20 * 44 - 2, -35, 4.1, -90);
    frame4.bracket.transition()
        .duration(1000)
        .attr("transform", newFrame4Transforms.bracket);
    frame4.t.transition()
        .duration(1000)
        .attr("transform", newFrame4Transforms.t);
    pathData = [58, 56, 42 + 1.5, 40 + 1.5];
    indicatorPath.transition()
        .duration(1000)
        .attr("d", pathFunction(pathData));
    genParent.transition()
        .duration(1000)
        .attr("transform", d3Transform()
            .translate([20 * 58, 0])
        );

    setBoardSquids(board, [
        {x: 4, y: 5, horizontal: true},
        {x: 5, y: 2, horizontal: false},
        {x: 1, y: 0, horizontal: false},
    ]);

    await nextSlide();
}

const videoElem = document.getElementById("gameClip");
const pausaIndicatorContainer = document.getElementById("pausaIndicatorContainer");

var globalViewBox = null;
var viewBoxIsLarge = true;
function toggleViewBoxSizing() {
    if (globalViewBox === null)
        return;
    if (viewBoxIsLarge) {
        globalViewBox.transition()
            .duration(1500)
            .attr("x", 1130).attr("y", 20)
            .attr("width", 1920 * 0.8 * 0.5).attr("height", 1080 * 0.8 * 0.5);
    } else {
        // FIXME: Make this always be synced with the transform below.
        globalViewBox.transition()
            .duration(1500)
            .attr("x", 1920 * 0.05).attr("y", 1080 * 0.05)
            .attr("width", 1920 * 0.9).attr("height", 1080 * 0.9);
    }
    viewBoxIsLarge = !viewBoxIsLarge;
}

async function showFirstBoardProgression(root) {
    // Make the axis arrows pop in.
    await sleep(250);
    const axisGroup = root.append("g");
    fadeIn(makeExtendoArrow(-30, 0, 1000, 0, axisGroup)[0]);
    fadeIn(makeExtendoArrow(0, 30, 0, -500, axisGroup)[0]);
    axisGroup.attr("transform", d3Transform().scale(1.5).translate([135, 570]));

    // Make the axis labels appear.
    await sleep(1000);
    const textGroup = axisGroup.append("g");
    const numRNGStepsText = textGroup.append("text")
        .text("Number of RNG steps")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "40px")
        .attr("font-style", "italic")
        .attr("transform", d3Transform()
            .translate([50 - 160, 120])
        );
    textGroup.append("text").text("0%")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "25px")
        .attr("font-style", "italic")
        .attr("transform", d3Transform()
            .translate([-45, -15])
        );
    textGroup.append("text").text("Probability")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "40px")
        .attr("font-style", "italic")
        .attr("transform", d3Transform()
            .translate([-40, -60])
            .rotate(-90)
        );
    textGroup.selectAll("text").transition()
        .duration(500)
        .attr("fill-opacity", 1);

    // Make the zero level pop in.
    const zeroLevel = axisGroup.append("line")
        .attr("x1", 0).attr("y1", -20).attr("x2", 0).attr("y2", -20)
        .attr("stroke-width", 1).attr("stroke", "black").attr("stroke-linecap", "round")
        .attr("stroke-dasharray", 10);
    zeroLevel
        .transition()
        .duration(1000)
        .attr("x2", 980)
        .attr("opacity", 1)
        .attr("stroke-width", 3);

    const tickTextGroup = axisGroup.append("g");

    // Make little tick marks appear.
    await sleep(1000);

    //debugPoint();

    // Make strategic reserves of ticks.
    const ticksGroup = axisGroup.append("g");
    ticksGroup.transition()
        .duration(1000)
        .attr("opacity", 1);
    const tickReserves = [];
    for (let i = 0; i < 400; i++) {
        const tick = ticksGroup.append("line")
            .attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 15)
            .attr("stroke-width", 2).attr("stroke", "black").attr("stroke-linecap", "round")
            .attr("opacity", 0).attr("fill", "none");
        tickReserves.push(tick);
    }
    const textReserves = [];
    for (let i = 0; i < 50; i++) {
        const text = ticksGroup.append("text").text("?")
            .attr("x", 0).attr("y", 0)
            .attr("font-family", "EB Garamond")
            .attr("font-size", "30px")
            //.attr("font-family", "monospace")
            //.attr("font-size", "20px")
            .attr("font-style", "italic")
            .attr("text-anchor", "middle");
        textReserves.push(text);
    }

    const proxyParameterObject = root.append("g");
    proxyParameterObject.attr("x", 0).attr("y", Math.log(1/30));
    const getAxisParameters = elapsed => {
        const scale = Math.max(1/30, Math.exp(+proxyParameterObject.attr("y")));
        return {
            left: +proxyParameterObject.attr("x") - scale * 15,
            scale,
        }
    };

    function renderNumber(scale, xWorldSpace) {
        if (xWorldSpace >= 1e6) {
            let s = (xWorldSpace / 1e6).toFixed(3);
            while (s.endsWith("0") || s.endsWith("."))
                s = s.slice(0, -1);
            return s + "M"
        }
        return Math.round(Math.max(0, xWorldSpace)).toLocaleString();
        //return "" + Math.round(xWorldSpace);
    }

    const clamp = x => Math.max(0, Math.min(1, x));

    var startTimestamp = null;
    const moveAxes = timestamp => {
        if (startTimestamp === null)
            startTimestamp = timestamp;
        const elapsed = timestamp - startTimestamp;
        if (keysHeld.has("a") || keysHeld.has("d")) {
            let scale = Math.exp(proxyParameterObject.attr("y"));
            scale *= keysHeld.has("d") - keysHeld.has("a");
            proxyParameterObject.attr("x", (+proxyParameterObject.attr("x")) + scale * 10);
        }
        if (keysHeld.has("w") || keysHeld.has("s")) {
            let scale = keysHeld.has("s") - keysHeld.has("w");
            proxyParameterObject.attr("y", (+proxyParameterObject.attr("y")) + scale * 0.01);
        }

        const params = getAxisParameters(timestamp);
        const splitBase = 10;
        // Round params.scale down to a power of 5.
        // This is the spacing in world-space units that we have a rendered tick for.
        const logScale = Math.log(params.scale * 30) / Math.log(splitBase);
        const smallestTickSpacingWorldSpace = Math.round(Math.exp(
            Math.floor(logScale) * Math.log(splitBase)
        ));
        const sizingError = logScale - Math.floor(logScale);
        // Round params.left down to a multiple of smallestTickSpacingWorldSpace.
        // This is the world-space offset of the leftmost tick we draw.
        let tickIndex = Math.ceil(params.left / smallestTickSpacingWorldSpace);
        let xWorldSpace = tickIndex * smallestTickSpacingWorldSpace;
        let ticksConsumed = 0;
        let textConsumed = 0;
        while (ticksConsumed < tickReserves.length) {
            if (xWorldSpace === 0)
                window.msg = true;
            const tickXScreenSpace = (xWorldSpace - params.left) / params.scale;
            if (tickXScreenSpace > 990)
                break;
            let tickSizeCategory = 1;
            if (tickIndex % splitBase === 0)
                tickSizeCategory = 2;
            if (tickIndex % Math.pow(splitBase, 2) === 0)
                tickSizeCategory = 3;
            tickSizeCategory -= sizingError;
            if (xWorldSpace === 0)
                tickSizeCategory = 3;

            let textSizeCategory = tickSizeCategory;
            // This bonus only applies when splitBase is even.
            if (
                tickIndex % splitBase === splitBase / 2 ||
                tickIndex % Math.pow(splitBase, 2) === Math.pow(splitBase, 2) / 2 ||
                tickIndex % Math.pow(splitBase, 3) === Math.pow(splitBase, 3) / 2
            )
                textSizeCategory += 0.65;

            // Do a non-linear transform on the tick size categories to squish it from [0, 2] up more towards the high end of that range.
            tickSizeCategory = Math.sqrt(tickSizeCategory / 2) * 2;
            // Fade out the ticks near the right end of the scale.
            const fadeOutDistance = 100;
            const leftFadeOpacity = Math.pow(clamp(tickXScreenSpace / fadeOutDistance), 1.5);
            const rightFadeOpacity = Math.pow(clamp(1 - (tickXScreenSpace - 990 + fadeOutDistance) / fadeOutDistance), 1.5);
            let masterOpacity = xWorldSpace >= 0 ? 1 : 0;

            // Don't draw turbo-tiny ticks.
            if (tickSizeCategory > 0.05) {
                const tick = tickReserves[ticksConsumed];
                tick.attr("opacity", masterOpacity * rightFadeOpacity).attr("x1", tickXScreenSpace).attr("x2", tickXScreenSpace);
                tick.attr("stroke-width", 1 + tickSizeCategory * 1.5);
                tick.attr("y2", 10 * Math.pow(tickSizeCategory, 0.75));
                ticksConsumed++;
            }

            if (textSizeCategory > 1.3) {
                const text = textReserves[textConsumed++];
                const textOpacity = clamp(textSizeCategory - 1.3);
                const textValue = renderNumber(params.scale, xWorldSpace);
                if (text !== undefined)
                    text.text(textValue)
                        .attr("opacity",
                            masterOpacity *
                            (textValue === "0" ? 1 : leftFadeOpacity) *
                            rightFadeOpacity *
                            textOpacity
                        )
                        .attr("x", tickXScreenSpace).attr("y", 55);
            }

            xWorldSpace += smallestTickSpacingWorldSpace;
            tickIndex++;
        }
        while (ticksConsumed < tickReserves.length)
            tickReserves[ticksConsumed++].attr("opacity", 0);
        while (textConsumed < textReserves.length)
            textReserves[textConsumed++].attr("opacity", 0);
        window.requestAnimationFrame(moveAxes);
    };
    window.requestAnimationFrame(moveAxes);

    function shiftAxisScale(left, scale, duration) {
        proxyParameterObject.transition()
            .duration(duration)
            .attr("x", left)
            .attr("y", Math.log(scale));
        return sleep(duration);
    }

    debugPoint();

    await nextSlide();
    const demoBoardGroup = root.append("g");
    for (let i = 0; i < 10; i++) {
        + (i % 2 === 0 ? 0 : 120)
        makeBoard(220 + 140 * i, -170, 0.3, axisGroup, 0.4, true, exampleSquidLayouts[i]);
        await sleep(100);
    }

    await nextSlide();
    shiftAxisScale(0, 8000, 10000);

    await nextSlide();
    shiftAxisScale(4.5e6, 2000, 5000);

    await nextSlide();
    shiftAxisScale(4.6474e6, 37, 10000);

    await nextSlide();
}

async function showPDFs(root) {
    await sleep(1000);
    // Make a view box appear.
    const viewBox = root.append("rect")
        .attr("x", 1920 * 0.05).attr("y", 1080 * 0.05)
        .attr("width", 1920 * 0.9).attr("height", 1080 * 0.9).attr("fill", "#333");
    viewBox.transition()
        .duration(1500)
        .attr("opacity", 1);
    globalViewBox = viewBox;

    var startTimestamp = null;
    smoothGameClipMotion = timestamp => {
        if (startTimestamp === null)
            startTimestamp = timestamp;
        const elapsed = timestamp - startTimestamp;
        const boundingRect = viewBox.node().getBoundingClientRect();
        let x = boundingRect.left;
        let y = boundingRect.top;
        let scale = (boundingRect.bottom - y) / 1440;
        scale *= 16 / 9;
        const opacity = elapsed / 1000;
        // This element scales relative to its middle, so we correct for that.
        x -= 1440 * (1 - scale) / 2;
        y -= 810 * (1 - scale) / 2;
        videoElem.style.transform = "translate(" + x + "px, " + y + "px) scale(" + scale + ")";
        videoElem.style.opacity = Math.min(1, opacity);
        pausaIndicatorContainer.style.transform = "translate(" + x + "px, " + y + "px) scale(" + scale + ")";
        pausaIndicatorContainer.style.opacity = Math.min(1, opacity);
        window.requestAnimationFrame(smoothGameClipMotion);
    }
    window.requestAnimationFrame(smoothGameClipMotion);
    //videoElem.play();

    //// Slide the viewbox into the top right.
    //await nextSlide();
    //toggleViewBoxSizing();

    // Make the axis arrows pop in.
    await nextSlide();
    const axisGroup = root.append("g");
    fadeIn(makeExtendoArrow(-30, 0, 1000, 0, axisGroup)[0]);
    fadeIn(makeExtendoArrow(0, 30, 0, -500, axisGroup)[0]);
    //axisGroup.attr("transform", d3Transform().scale(1.5).translate([135, 600]));
    axisGroup.attr("transform", d3Transform().scale(1.4).translate([130, 680]));

    // Make the axis labels appear.
    await sleep(1000);
    const textGroup = axisGroup.append("g");
    const numRNGStepsText = textGroup.append("text")
        .text("Number of RNG steps")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "40px")
        .attr("font-style", "italic")
        .attr("transform", d3Transform()
            .translate([50 - 160, 70])
        );
    textGroup.append("text").text("0%")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "25px")
        .attr("font-style", "italic")
        .attr("transform", d3Transform()
            .translate([-45, -15])
        );
    textGroup.append("text").text("Probability")
        .attr("x", 0).attr("y", 0)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "40px")
        .attr("font-style", "italic")
        .attr("transform", d3Transform()
            .translate([-40, -60])
            .rotate(-90)
        );
    textGroup.selectAll("text").transition()
        .duration(500)
        .attr("fill-opacity", 1);

    // Make the zero level pop in.
    const zeroLevel = axisGroup.append("line")
        .attr("x1", 0).attr("y1", -20).attr("x2", 0).attr("y2", -20)
        .attr("stroke-width", 1).attr("stroke", "black").attr("stroke-linecap", "round")
        .attr("stroke-dasharray", 10);
    zeroLevel
        .transition()
        .duration(1000)
        .attr("x2", 980)
        .attr("opacity", 1)
        .attr("stroke-width", 3);

    // Make little tick marks appear.
    await sleep(1000);
    const ticksGroup = axisGroup.append("g");
    for (let i = 0; i < 98; i++) {
        await sleep(10);

        const x = 10 + 10 * i

        const tick = ticksGroup.append("line")
            .attr("x1", x).attr("y1", 0).attr("x2", x).attr("y2", 0)
            .attr("stroke-width", 0).attr("stroke", "black").attr("stroke-linecap", "round")
            .attr("fill", "none");
        if (i % 5 == 0) {
            tick.transition()
                .duration(500)
                .attr("stroke-width", 3)
                .attr("y2", 20);
        } else {
            tick.transition()
                .duration(500)
                .attr("stroke-width", 2)
                .attr("y2", 15);
        }
    }

    // Draw the mean RNG step count estimate dashed line.
    await nextSlide();
    const meanX = 20 + 25 * 19;
    const meanSpot = axisGroup.append("line")
        .attr("x1", meanX).attr("y1", -400).attr("x2", meanX).attr("y2", -400)
        .attr("stroke-width", 1).attr("stroke", "black").attr("stroke-linecap", "round")
        .attr("stroke-dasharray", 10);
    meanSpot
        .transition()
        .duration(1000)
        .attr("y2", 0)
        .attr("opacity", 1)
        .attr("stroke-width", 3);
    axisGroup.append("text").text("5.5 million steps")
        .attr("x", meanX).attr("y", -420)
        .attr("font-family", "EB Garamond")
        .attr("font-size", "35px")
        .attr("font-style", "italic")
        .attr("text-anchor", "middle")
        .transition()
        .duration(500)
        .attr("fill-opacity", 1);

    // Draw a bell curve.
    await nextSlide();
    const bellCurveGroup = axisGroup.append("g"); // I want this just to animate opacity separately.
    let pathData = [];
    for (let i = 0; i < 500; i++) {
        const x = (250 - i) / 80;
        pathData.push(300 * Math.exp(-x*x));
    }
    const pathFunction = d3.line()
        .x(function(d, i) { return 1.9 * i; })
        .y(function(d, i) { return -d; })
        .curve(d3.curveBasis);
    const bellCurvePath = bellCurveGroup.append("path");
    bellCurvePath.attr("d", pathFunction(pathData))
        .attr("stroke-width", 4).attr("stroke", "#22f").attr("stroke-linecap", "round").attr("stroke-opacity", 0.6)
        .attr("fill", "blue");
    const length = bellCurvePath.node().getTotalLength();
    bellCurvePath.attr("stroke-dasharray", length).attr("stroke-dashoffset", length);
    bellCurvePath.attr("transform", d3Transform()
        .translate([20, -20])
    );
    bellCurveGroup
        .transition()
        .duration(1000)
        .attr("opacity", 1);
    bellCurvePath
        .transition()
        .duration(2000)
        .attr("stroke-dashoffset", 0)
        .attr("fill-opacity", 0.2);

    // Show the squid layout that the player has seen in-game, and we narrow down based on.
    await nextSlide();
    const board = await makeBoard(300, -370, 0.6, axisGroup, 0.6, true);
    await sleep(1500); // XXX: This value must wait for the board to fully color!

    // Fill in the board.
    await nextSlide();
    setBoardSquids(board, [
        {x: 5, y: 5, horizontal: true},
        {x: 4, y: 1, horizontal: true},
        {x: 2, y: 1, horizontal: false},
    ]);

    /*
    // When should I hide this text?
    numRNGStepsText.attr("x", 0);
    numRNGStepsText.transition()
        .duration(1000)
        .attr("x", -160);
        //.attr("fill-opacity", 0);
    */

    // Show the spots where we saw this board.
    await nextSlide();
    function drawExtendoPath(x1, y1, x2, y2) {
        const indicatorPath = axisGroup.append("path");
        const pathFunction = d3.line()
            .x(d => d[0]).y(d => d[1])
            .curve(d3.curveBasis);
        const pathData = [[x1, y1], [x1, (y1 + y2) / 2], [x2, (y1 + y2) / 2], [x2, y2]];
        indicatorPath.attr("d", pathFunction(pathData))
            .attr("stroke-width", 4).attr("stroke", "black").attr("stroke-linecap", "round")
            .attr("fill", "none").attr("marker-end", "url(#arrowHead)");
        const length = indicatorPath.node().getTotalLength();
        indicatorPath.attr("stroke-dasharray", length).attr("stroke-dashoffset", length);
        indicatorPath.transition()
            .duration(1000)
            .attr("stroke-dashoffset", 0)
            .attr("opacity", 1);
        return indicatorPath;
    }
    const disregard1 = drawExtendoPath(236, -335, 127, -54);
    await sleep(200);
    const regard1 = drawExtendoPath(236, -335, 350, -54);
    await sleep(200);
    const regard2 = drawExtendoPath(236, -335, 550, -54);
    await sleep(200);
    const disregard2 = drawExtendoPath(236, -335, 821, -54);

    // Disregard the far away matches.
    await nextSlide();
    const rejectX1 = drawX(axisGroup, 127, -40, 25, "red");
    disregard1.transition()
        .duration(1000)
        .attr("opacity", 0.1);
    await sleep(500);
    const rejectX2 = drawX(axisGroup, 821, -40, 25, "red");
    disregard2.transition()
        .duration(1000)
        .attr("opacity", 0.1);

    // Get the probabilities of our matches.
    // 31.6% for the low one - 68.4% for the high one
    await nextSlide();
    async function getProbLine(x, height, xOff, bottomLabel, label) {
        const l = axisGroup.append("line")
            .attr("x1", x).attr("y1", -22).attr("x2", x).attr("y2", -22)
            .attr("stroke-width", 1).attr("stroke", "#00d").attr("stroke-linecap", "round")
            .attr("stroke-dasharray", 13.5);
        l.transition()
            .duration(2000)
            .attr("y2", -height)
            .attr("opacity", 1)
            .attr("stroke-width", 6);
        const bottomText = axisGroup.append("text").text(bottomLabel)
            .attr("x", x).attr("y", 60)
            .attr("font-family", "EB Garamond")
            .attr("font-size", "35px")
            .attr("font-style", "italic")
            .attr("text-anchor", "middle")
            .transition()
            .duration(500)
            .attr("fill-opacity", 1);
        await sleep(2000);
        const flag = axisGroup.append("line")
            .attr("x1", x).attr("y1", -height).attr("x2", x).attr("y2", -height)
            .attr("stroke-width", 1).attr("stroke", "#00d").attr("stroke-linecap", "round");
        flag.transition()
            .duration(600)
            .attr("x2", x + xOff)
            .attr("opacity", 1)
            .attr("stroke-width", 6);
        await sleep(1000);
        const delta = xOff > 0 ? 50 : -50;
        const flagText = axisGroup.append("text").text(label)
            .attr("x", x + xOff + delta).attr("y", -height + 10)
            .attr("font-family", "EB Garamond")
            .attr("font-size", "35px")
            .attr("font-style", "italic")
            .attr("text-anchor", "middle")
            .transition()
            .duration(500)
            .attr("fill-opacity", 1);
    }
    for (const r of [regard1, regard2])
        r.transition()
            .duration(1000)
            .attr("opacity", 0.3);
    for (const r of [rejectX1, rejectX2])
        r.attr("opacity", 1)
            .transition()
                .duration(1000)
                .attr("opacity", 0.1);
    await sleep(500);
    getProbLine(350, 140, -70, "5.389M", "31.6%"); // ~145 before middle
    getProbLine(550, 280, -150, "5.542M", "68.4%"); // ~55 after middle
    // Clean up all the old nonsense.
    await sleep(1000);
    for (const o of [disregard1, rejectX1, regard1, regard2, disregard2, rejectX2])
        o.transition()
            .duration(1000)
            .attr("opacity", 0);

    // Make the new curve.
    await nextSlide();
    pathData = [];
    for (let i = 0; i < 500; i++) {
        // No, I don't particularly strive for proper normalization here.
        // I'm going more for something aesthetically pleasing. :)
        let accum = 0;
        let x = (190 - i) / 5;
        accum += 0.316 * 500 * Math.exp(-x*x);
        x = (296 - i) / 5;
        accum += 0.684 * 500 * Math.exp(-x*x);
        pathData.push(accum);
    }
    bellCurvePath.attr("stroke-dasharray", "");
    bellCurvePath.transition()
        .duration(1000)
        .attr("d", pathFunction(pathData));

    // Emphasize the curve.
    await nextSlide();
    const emphBellCurvePath = bellCurveGroup.append("path");
    emphBellCurvePath.attr("d", pathFunction(pathData))
        .attr("stroke-width", 5).attr("stroke", "#22f").attr("stroke-linecap", "round")
        .attr("fill", "none");
    emphBellCurvePath.attr("stroke-dasharray", 0.05 * length).attr("stroke-dashoffset", 0);
    emphBellCurvePath.attr("transform", d3Transform()
        .translate([20, -20])
    );
    const emphDuration = 4000;
    bellCurvePath.attr("opacity", 1);
    bellCurvePath
        .transition()
        .duration(0.2 * emphDuration)
        .ease(d3.easeLinear)
        .attr("opacity", 0.9)

        .transition()
        .duration(0.6 * emphDuration)

        .transition()
        .duration(0.2 * emphDuration)
        .ease(d3.easeLinear)
        .attr("opacity", 1);
    emphBellCurvePath
        .transition()
        .duration(0.2 * emphDuration)
        .ease(d3.easeLinear)
        .attr("opacity", 1)
        .attr("stroke-dashoffset", 0.2 * length)

        .transition()
        .duration(0.6 * emphDuration)
        .ease(d3.easeLinear)
        .attr("stroke-dashoffset", 0.8 * length)

        .transition()
        .duration(0.2 * emphDuration)
        .ease(d3.easeLinear)
        .attr("opacity", 0)
        .attr("stroke-dashoffset", 1.0 * length);
    await sleep(emphDuration);

    await nextSlide();
}

async function doSlide(slideFn) {
    const slideRoot = svg.append("g");
    slideRoot.attr("opacity", 1);
    await slideFn(slideRoot);
    await sleep(1000);
    slideRoot.transition()
        .duration(1500)
        .attr("opacity", 0);
    await sleep(1500);
    slideRoot.remove();
}

async function main() {
    //globalTimeScale = 0.3;
    //debugPoint();
    //await doSlide(showBoardAveraging);
    //await doSlide(showBoardSequence);
    //await doSlide(showRNGSequence);
    //await doSlide(showBoardSampling);
    //await doSlide(showPDFs);
    await doSlide(showFirstBoardProgression);
}

var globalNextSlideContinuation = null;

function nextSlide() {
    if (skipThrough)
        return sleep(1500);
    return new Promise(resolve => {
        globalNextSlideContinuation = resolve;
        document.getElementById("messageBox").innerText = "Press space to advance...";
    });
    return promise;
}

function debugPoint(timeScale) {
    skipThrough = false;
    globalTimeScale = timeScale === undefined ? 1.0: timeScale;
    //return nextSlide();
}

const keysHeld = new Set();

function globalShortcutsHandler(evt) {
    keysHeld.add(evt.key);
    if (evt.key === " ") {
        if (globalNextSlideContinuation !== null) {
            document.getElementById("messageBox").innerText = "";
            const resolve = globalNextSlideContinuation;
            async function asynchronouslyResolve() {
                resolve();
            }
            // I do this so that the key handler can return immediately.
            asynchronouslyResolve();
        }
        evt.preventDefault();
    }
    // Pausa video.
    if (evt.key === "z" || evt.key === "y") {
        videoElem.pause();
        document.getElementById("pausaIndicator").innerText = "⏸";
        document.getElementById("pausaIndicatorFloat").className = "";
    }
    // Play video.
    if (evt.key === "x") {
        videoElem.playbackRate = 1.0;
        videoElem.play();
        document.getElementById("pausaIndicator").innerText = "⏵";
        document.getElementById("pausaIndicatorFloat").className = "waveSlow";
    }
    // Fast forward video.
    if (evt.key === "c") {
        videoElem.playbackRate = 3.0;
        videoElem.play();
        document.getElementById("pausaIndicator").innerText = "⏩️";
        document.getElementById("pausaIndicatorFloat").className = "waveFast";
    }
    // Toggle video scale.
    if (evt.key === "v") {
        toggleViewBoxSizing();
    }
}

document.addEventListener("keydown", globalShortcutsHandler);
document.addEventListener("keyup", function(evt) {
    keysHeld.delete(evt.key);
});

main();

        </script>
    </body>
</html>
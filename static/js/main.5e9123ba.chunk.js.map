{"version":3,"sources":["wasm/sploosh_wasm.js","App.js","serviceWorker.js","index.js"],"names":["wasm","cachegetUint8Memory0","WASM_VECTOR_LEN","passArray8ToWasm0","arg","malloc","ptr","length","buffer","memory","Uint8Array","set","cachegetInt32Memory0","getInt32Memory0","Int32Array","cachegetFloat64Memory0","getArrayF64FromWasm0","len","Float64Array","subarray","calculate_probabilities","hits","misses","squids_gotten","ptr0","__wbindgen_malloc","len0","ptr1","len1","v2","r0","r1","slice","__wbindgen_free","load","module","imports","a","Response","WebAssembly","instantiateStreaming","headers","get","console","warn","arrayBuffer","bytes","instantiate","instance","Instance","init","input","Request","URL","fetch","exports","__wbindgen_wasm_module","colormap","require","interpolate","naturalsUpTo","n","Array","keys","Tile","isBest","this","props","best","x","y","key","style","display","justifyContent","alignItems","textAlign","width","height","border","valid","outline","zIndex","fontFamily","userSelect","MozUserSelect","WebkitUserSelect","msUserSelect","color","opacity","backgroundColor","text","prob","onClick","toFixed","precision","React","Component","process","window","JUST_ONCE","globalMap","tryToProcessFrame","readyToProcess","state","doVideoProcessing","readBoardState","globalProcessingTick","setTimeout","sampleSquid","Math","round","random","direction","cells","i","cell","newXY","push","MainMap","videoRef","createRef","canvasRef","outputCanvasRef","hiddenAreaRef","makeEmptyState","bannerCache","Map","doComputation","grid","squidsGotten","RECOMP","getBoardRegistrationAndScale","previouslyReadStates","makeReferenceImageCanvases","hiddenArea","current","referenceCanvases","name","newCanvas","document","createElement","setAttribute","appendChild","newImage","src","onload","log","getContext","drawImage","probs","mode","squidLayout","layout","hitLocations","candidate","isAdmissible","generateLayout","observationProb","screenRecordingActive","lastComputationTime","lastCVTime","alert","displayMediaOptions","video","cursor","audio","navigator","mediaDevices","getDisplayMedia","captureStream","srcObject","play","setState","Promise","resolve","updateCapture","canvas","outputCanvas","resultantState","bestGuessScale","searchMargin","performGridSearch","boardFitParams","scale","delete","testForTopBannerAtScale","testForBottomBanner","min","max","sampleCount","bestParams","score","testScale","params","cv","imread","base_templ","scaled_banner_width","size","scaled_banner_height","templ","Mat","dsize","Size","resize","INTER_AREA","dst","mask","matchMode","TM_CCOEFF_NORMED","matchTemplate","maxPoint","minMaxLoc","maxLoc","Scalar","point","Point","cols","rows","rectangle","LINE_8","imshow","bottomBannerOffset","aspectRatioFactor","topBannerOffset","Rect","has","result","maxVal","undefined","hasOwnProperty","compareStatesEqual","A","B","allEqual","t0","performance","now","ksize","GaussianBlur","BORDER_DEFAULT","toDelete","getPixelColor","pixelPtr","ucharPtr","pixelColor","r","g","b","energy","sqrt","nothingColor","hitColor","missColor","killedSquidColor","remainingSquidColor","mostLikelyCursorLocation","bestCursorScore","cellXY","getCellXY","wayDown","centerX","centerY","center","upLeft","upRight","downLeft","downRight","probablyInsideCursor","cursorHaloLeft","cursorHaloRight","cursorHaloUp","cursorHaloDown","cursorHaloUL","cursorHaloUR","cursorHaloDL","cursorHaloDR","threshold","passingCount","greenerMargin","greenerThanBlueCount","maxRed","maxGreen","tl","br","squidIndex","getSquidIndicatorXY","boardRect","getBoardRect","srcCrop","roi","t1","shift","context","videoHeight","videoWidth","gridValue","Number","probabilities","from","maxY","maxX","highestProb","arr","arrayContains","squid2","squid3","squid4","squid","killed","newState","overlayMode","map","position","top","left","transform","renderActualMap","usedShots","openingOptimizer","margin","fontSize","marginLeft","value","onChange","event","target","clearField","marginTop","startScreenRecording","disabled","toggleVideoProcessing","ref","id","renderOverlayMap","addEventListener","evt","App","body","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.5e9123ba.chunk.js","sourcesContent":["\nlet wasm;\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n\nfunction getArrayF64FromWasm0(ptr, len) {\n    return getFloat64Memory0().subarray(ptr / 8, ptr / 8 + len);\n}\n/**\n* Calculates the probabilities for each cell based on the hits, misses and the\n* squids that have already been killed.\n* @param {Uint8Array} hits\n* @param {Uint8Array} misses\n* @param {number} squids_gotten\n* @returns {Float64Array | undefined}\n*/\nexport function calculate_probabilities(hits, misses, squids_gotten) {\n    var ptr0 = passArray8ToWasm0(hits, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArray8ToWasm0(misses, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    wasm.calculate_probabilities(8, ptr0, len0, ptr1, len1, squids_gotten);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    let v2;\n    if (r0 !== 0) {\n        v2 = getArrayF64FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 8);\n    }\n    return v2;\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nasync function init(input) {\n    // if (typeof input === 'undefined') {\n    //     input = import.meta.url.replace(/\\.js$/, '_bg.wasm');\n    // }\n    const imports = {};\n\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    const { instance, module } = await load(await input, imports);\n\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n\n    return wasm;\n}\n\nexport default init;\n\n","import React from 'react';\nimport './App.css';\nimport init, { calculate_probabilities } from './wasm/sploosh_wasm.js';\nconst interpolate = require('color-interpolate');\n//const opencv = require('opencv.js');\n\n//const colormap = interpolate(['#004', '#090', '#0a0', 'green']);\n//const colormap = interpolate(['#004', '#0a0', '#0d0', '#0f0', '#6f6']);\n// .        . . . .\n// 0123456789abcdef\nconst colormap = interpolate(['#004', '#070', '#090', '#0b0', '#0d0', '#0f0', '#6f6']);\nconst naturalsUpTo = (n) => [...Array(n).keys()];\n\nclass Tile extends React.Component {\n    render() {\n        const isBest = this.props.best !== null && this.props.best[0] == this.props.x && this.props.best[1] == this.props.y;\n\n        return <div\n            key={this.props.x + ',' + this.props.y}\n            style={{\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n                textAlign: 'center',\n                width: '70px',\n                height: '70px',\n                border: this.props.valid ? '1px solid grey' : '1px solid red',\n                outline: isBest ? '4px solid yellow' : '',\n                zIndex: isBest ? 1 : 0,\n                fontFamily: 'monospace',\n                userSelect: 'none',\n                MozUserSelect: 'none',\n                WebkitUserSelect: 'none',\n                msUserSelect: 'none',\n                color: 'white',\n                opacity: this.props.opacity,\n                backgroundColor: this.props.text === null ? colormap(this.props.prob) : (\n                    this.props.text === 'HIT' ? '#a2a' : '#44a'\n                ),\n            }}\n            onClick={this.props.onClick}\n        >\n            {this.props.text === null ? (this.props.prob * 100).toFixed(this.props.precision) + '%' : this.props.text}\n        </div>;\n    }\n}\n\nlet wasm = init(process.env.PUBLIC_URL + \"/sploosh_wasm_bg.wasm\");\n\n// Debugging value, ignore me.\nwindow.JUST_ONCE = false;\n\n// Super ugly, please forgive me. :(\nvar globalMap = null;\n\nasync function tryToProcessFrame() {\n    if (globalMap === null)\n        return;\n    if (globalMap.readyToProcess() && globalMap.state.doVideoProcessing)\n        await globalMap.readBoardState();\n}\n\nasync function globalProcessingTick() {\n    await tryToProcessFrame();\n    // We use setTimeout nested like this rather than setInterval so that the ticks\n    // don't get bunched up if the processing takes too long.\n    setTimeout(globalProcessingTick, 25);\n}\n\nif (!window.JUST_ONCE) {\n    globalProcessingTick();\n    /*\n    setInterval(\n        () => {\n            \n        },\n        50,\n    );\n    */\n}\n\nfunction sampleSquid(length) {\n    const x = Math.round(Math.random() * 8);\n    const y = Math.round(Math.random() * 8);\n    const direction = Math.random() < 0.5;\n    const cells = [[x, y]];\n    for (let i = 0; i < length - 1; i++) {\n        const cell = cells[cells.length - 1];\n        const newXY = direction ? [cell[0] + 1, cell[1]] : [cell[0], cell[1] + 1];\n        cells.push(newXY);\n    }\n    return cells;\n}\n\nfunction generateLayout() {\n    const layout = {};\n    const hitLocations = {};\n    for (const n of [2, 3, 4]) {\n        while (true) {\n            const candidate = sampleSquid(n);\n            let isAdmissible = true;\n            for (const cell of candidate)\n                if (cell[0] > 7 || cell[1] > 7 || hitLocations[cell] === true)\n                    isAdmissible = false;\n            if (isAdmissible) {\n                layout['squid' + n] = candidate;\n                for (const cell of candidate)\n                    hitLocations[cell] = true;\n                break;\n            }\n        }\n    }\n    console.log('Generated:', layout);\n    return layout;\n}\n\nclass MainMap extends React.Component {\n    videoRef = React.createRef();\n    canvasRef = React.createRef();\n    //referenceCanvasRef = React.createRef();\n    outputCanvasRef = React.createRef();\n    hiddenAreaRef = React.createRef();\n\n    constructor() {\n        super();\n        this.state = this.makeEmptyState();\n        this.bannerCache = new Map();\n        this.doComputation(this.state.grid, this.state.squidsGotten);\n        window.RECOMP = () => {\n            this.bannerCache = new Map();\n            this.getBoardRegistrationAndScale();\n        };\n        globalMap = this;\n        this.previouslyReadStates = [null, null, null];\n    }\n\n    componentDidMount() {\n        this.makeReferenceImageCanvases();\n        //setTimeout(() => this.getScreenRecording(), 1000);\n    }\n\n    makeReferenceImageCanvases() {\n        const hiddenArea = this.hiddenAreaRef.current;\n        this.referenceCanvases = {};\n        // 'top_banner', 'record_banner',\n        for (const name of ['hit', 'miss', 'killed_squid', 'remaining_squid', 'top_banner_new', 'bottom_banner_new']) {\n            const newCanvas = document.createElement('canvas');\n            newCanvas.setAttribute('id', 'canvas_' + name);\n            hiddenArea.appendChild(newCanvas);\n\n            const newImage = document.createElement('img');\n            newImage.src = process.env.PUBLIC_URL + '/images/' + name + '.png';\n            newImage.onload = function() {\n                console.log(\"Width:\", this.width, this.height, this);\n                newCanvas.width = this.width;\n                newCanvas.height = this.height;\n                const ctx = newCanvas.getContext('2d');\n                ctx.drawImage(newImage, 0, 0);\n            };\n            this.referenceCanvases[name] = newCanvas;\n        }\n    }\n\n    makeEmptyState() {\n        const grid = [];\n        const probs = [];\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                grid[[x, y]] = null;\n                probs[[x, y]] = 0.0;\n            }\n        }\n        // Select a particular layout, for practice mode.\n        const squidLayout = generateLayout();\n        return {\n            mode: 'calculator',\n            squidLayout,\n            grid,\n            squidsGotten: 'unknown',\n            probs,\n            best: [3, 3],\n            valid: true,\n            observationProb: 1.0,\n            screenRecordingActive: false,\n            doVideoProcessing: false,\n            lastComputationTime: -1,\n            lastCVTime: -1,\n        };\n    }\n\n    async startScreenRecording() {\n        if (this.state.screenRecordingActive) {\n            alert('Already screen capturing!');\n            return;\n        }\n        const displayMediaOptions = {\n            video: {\n              cursor: \"always\",\n            },\n            audio: false,\n        };\n        const captureStream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);\n        const video = this.videoRef.current;\n        video.srcObject = captureStream;\n        video.play();\n        this.setState({screenRecordingActive: true});\n        // Ugh, super ugly. I should just wait for the video appropriately. The API gives a callback.\n        // Please forgive me, it's 5 AM where I am, and Linkus starts in ~4 hours.\n        await new Promise(resolve => setTimeout(resolve, 500));\n        this.updateCapture();\n        const canvas = this.canvasRef.current;\n        const outputCanvas = this.outputCanvasRef.current;\n        console.log(canvas, outputCanvas, canvas.width, canvas.height)\n        outputCanvas.width = canvas.width;\n        outputCanvas.height = canvas.height;\n        const ctx = outputCanvas.getContext('2d');\n        ctx.drawImage(canvas, 0, 0);\n        /*\n        setTimeout(\n            () => this.getBoardRegistrationAndScale(),\n            1000,\n        );\n        */\n    }\n\n    toggleVideoProcessing() {\n        if (!this.state.screenRecordingActive)\n            return;\n        if (this.state.doVideoProcessing === false && !this.readyToProcess()) {\n            alert('You must first detect a board.');\n            return;\n        }\n        this.setState({doVideoProcessing: !this.state.doVideoProcessing});\n        // If we have a queued up board that hasn't verified as debounced yet, just process it.\n        if (this.previouslyReadStates[this.previouslyReadStates.length - 1] !== null) {\n            const resultantState = this.previouslyReadStates[this.previouslyReadStates.length - 1];\n            this.setState(resultantState);\n            this.doComputation(resultantState.grid, resultantState.squidsGotten);\n            this.previouslyReadStates[this.previouslyReadStates.length - 1] = null;\n        }\n    }\n\n    async getBoardRegistrationAndScale() {\n        if (!this.state.screenRecordingActive)\n            return;\n        this.updateCapture();\n        let bestGuessScale = 0.25 * 1.5; //0.5;\n        let searchMargin = 0.7;\n        for (let i = 0; i < 10; i++) {\n            this.boardFitParams = await this.performGridSearch(\n                bestGuessScale * (1 - searchMargin),\n                bestGuessScale * (1 + 2 * searchMargin),\n                i == 0 ? 20 : (i == 1 ? 10 : 4),\n            );\n            bestGuessScale = this.boardFitParams.scale;\n            searchMargin /= 2;\n        }\n        console.log('Best fit params:', this.boardFitParams);\n        // Force a rerender.\n        this.bannerCache.delete(bestGuessScale);\n        this.testForTopBannerAtScale(bestGuessScale);\n        this.testForBottomBanner();\n        console.log('Final fit params:', this.boardFitParams);\n        await new Promise(resolve => setTimeout(resolve, 100));\n        this.setState({doVideoProcessing: true});\n        /*\n        setTimeout(\n            () => this.readBoardState(),\n            250,\n        )\n        //*/\n        //*\n    }\n\n    async performGridSearch(min, max, sampleCount) {\n        let bestParams = {score: -1};\n        for (let i = 0; i < sampleCount; i++) {\n            const testScale = min + i * (max - min) / (sampleCount - 1);\n            const params = this.testForTopBannerAtScale(testScale);\n            if (params.score > bestParams.score)\n                bestParams = params;\n            await new Promise(resolve => setTimeout(resolve, 10));\n        }\n        console.log(\"Grid search over:\", min, \"to\", max, \"got:\", bestParams);\n        return bestParams;\n    }\n\n    testForBottomBanner() {\n        const src = window.cv.imread('cv_canvasRef');\n\n        const base_templ = window.cv.imread('canvas_bottom_banner_new');\n        const scaled_banner_width = Math.round(base_templ.size().width * this.boardFitParams.scale);\n        const scaled_banner_height = Math.round(base_templ.size().height * this.boardFitParams.scale);\n        let templ = new window.cv.Mat();\n        let dsize = new window.cv.Size(scaled_banner_width, scaled_banner_height);\n        window.cv.resize(base_templ, templ, dsize, 0, 0, window.cv.INTER_AREA);\n\n        const dst = new window.cv.Mat();\n        const mask = new window.cv.Mat();\n        const matchMode = window.cv.TM_CCOEFF_NORMED;\n        window.cv.matchTemplate(src, templ, dst, matchMode, mask);\n        let result = window.cv.minMaxLoc(dst, mask);\n        let maxPoint = result.maxLoc;\n        let color = new window.cv.Scalar(255, 0, 0, 255);\n        let point = new window.cv.Point(maxPoint.x + templ.cols, maxPoint.y + templ.rows);\n        window.cv.rectangle(src, maxPoint, point, color, 2, window.cv.LINE_8, 0);\n        window.cv.imshow('cv_outputCanvasRef', src);\n        src.delete(); base_templ.delete(); templ.delete(); dst.delete(); mask.delete();\n        this.boardFitParams.bottomBannerOffset = {\n            x: maxPoint.x, y: maxPoint.y,\n        };\n    }\n\n    getCellXY(x, y) {\n        const bannerVerticalSpacing = this.boardFitParams.bottomBannerOffset.y - this.boardFitParams.topBannerOffset.y;\n        let aspectRatioFactor = bannerVerticalSpacing / (828 * this.boardFitParams.scale);\n        if (aspectRatioFactor < 0.95 || aspectRatioFactor > 1.05)\n            aspectRatioFactor = 1;\n\n        //const aspectRatioFactor = 1.0;\n        // Center of 0,0 cell: 161, 244\n        // Center of 1,0 cell: 240, 244\n        // Top of bottom banner: 832\n\n        //let centerX = offsetX + scale * (105.25 + x * 52.2 + window.ADJUST_X);\n        //let centerY = offsetY + scale * (155.75 + y * 52.2 + window.ADJUST_Y);\n        return {\n            x: this.boardFitParams.topBannerOffset.x + this.boardFitParams.scale * (161.5 + 75.5 * x),\n            y: this.boardFitParams.topBannerOffset.y + this.boardFitParams.scale * aspectRatioFactor * (239 + 78.6 * y),\n        };\n    }\n\n    getSquidIndicatorXY(y) {\n        const bannerVerticalSpacing = this.boardFitParams.bottomBannerOffset.y - this.boardFitParams.topBannerOffset.y;\n        let aspectRatioFactor = bannerVerticalSpacing / (828 * this.boardFitParams.scale);\n        if (aspectRatioFactor < 0.95 || aspectRatioFactor > 1.05)\n            aspectRatioFactor = 1;\n        //const aspectRatioFactor = 1.0;\n        // Center of 0,0 squid: 948, 188\n        // Center of 1,0 squid: 948, 324\n\n        return {\n            x: this.boardFitParams.topBannerOffset.x + this.boardFitParams.scale * 948,\n            y: this.boardFitParams.topBannerOffset.y + this.boardFitParams.scale * aspectRatioFactor * (185 + 133 * y),\n        };\n    }\n\n    getBoardRect() {\n        const bannerVerticalSpacing = this.boardFitParams.bottomBannerOffset.y - this.boardFitParams.topBannerOffset.y;\n        let aspectRatioFactor = bannerVerticalSpacing / (828 * this.boardFitParams.scale);\n        if (aspectRatioFactor < 0.95 || aspectRatioFactor > 1.05)\n            aspectRatioFactor = 1;\n        return new window.cv.Rect(\n            Math.round(this.boardFitParams.topBannerOffset.x), Math.round(this.boardFitParams.topBannerOffset.y),\n            Math.round(this.boardFitParams.scale * 1040),\n            Math.round(this.boardFitParams.scale * aspectRatioFactor * 940),\n        );\n    }\n\n    testForTopBannerAtScale(scale) {\n        if (this.bannerCache.has(scale)) {\n            return this.bannerCache.get(scale);\n        }\n        const src = window.cv.imread('cv_canvasRef');\n        const base_templ = window.cv.imread('canvas_top_banner_new');\n\n        const scaled_banner_width = Math.round(base_templ.size().width * scale);\n        const scaled_banner_height = Math.round(base_templ.size().height * scale);\n        let templ = new window.cv.Mat();\n        let dsize = new window.cv.Size(scaled_banner_width, scaled_banner_height);\n        window.cv.resize(base_templ, templ, dsize, 0, 0, window.cv.INTER_AREA);\n\n        const dst = new window.cv.Mat();\n        const mask = new window.cv.Mat();\n        //const matchMode = window.cv.TM_CCOEFF_NORMED;\n        const matchMode = window.cv.TM_CCOEFF_NORMED;\n        window.cv.matchTemplate(src, templ, dst, matchMode, mask);\n        let result = window.cv.minMaxLoc(dst, mask);\n        let maxPoint = result.maxLoc;\n        let color = new window.cv.Scalar(255, 0, 0, 255);\n        let point = new window.cv.Point(maxPoint.x + templ.cols, maxPoint.y + templ.rows);\n        window.cv.rectangle(src, maxPoint, point, color, 2, window.cv.LINE_8, 0);\n        window.cv.imshow('cv_outputCanvasRef', src);\n        src.delete(); base_templ.delete(); templ.delete(); dst.delete(); mask.delete();\n\n        let score = result.maxVal;\n        this.bannerCache.set(scale, score);\n        return {\n            score, scale,\n            topBannerOffset: {x: maxPoint.x, y: maxPoint.y},\n        };\n    }\n\n    readyToProcess() {\n        return this.state.screenRecordingActive &&\n            this.boardFitParams !== undefined &&\n            this.boardFitParams.hasOwnProperty('bottomBannerOffset');\n    }\n\n    async readBoardState() {\n        if (!this.readyToProcess())\n            return;\n\n        const resultantState = {\n            grid: {},\n            squidsGotten: 0,\n        };\n\n        this.updateCapture();\n        const t0 = performance.now();\n\n        const src = window.cv.imread('cv_canvasRef');\n        const ksize = new window.cv.Size(3, 3);\n        window.cv.GaussianBlur(src, src, ksize, 0, 0, window.cv.BORDER_DEFAULT);\n        const toDelete = [src];\n\n        const getPixelColor = (x, y) => {\n            const pixelPtr = src.ucharPtr(Math.round(y), Math.round(x));\n            const pixelColor = {r: pixelPtr[0], g: pixelPtr[1], b: pixelPtr[2]};\n            const energy = Math.sqrt(pixelColor.r * pixelColor.r + pixelColor.g * pixelColor.g + pixelColor.b * pixelColor.b);\n            return {...pixelColor, energy};\n        };\n\n        // Extract the info.\n        let nothingColor        = new window.cv.Scalar(80,  80,  80,  255);\n        let hitColor            = new window.cv.Scalar(255, 0,   255, 255);\n        let missColor           = new window.cv.Scalar(100, 255, 0,   255);\n        let killedSquidColor    = new window.cv.Scalar(255, 100, 100, 255);\n        let remainingSquidColor = new window.cv.Scalar(50,  255, 100, 255);\n        let mostLikelyCursorLocation = null;\n        let bestCursorScore = -1;\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                const cellXY = this.getCellXY(x, y);\n                const wayDown = getPixelColor(cellXY.x, cellXY.y + 15);\n                if (wayDown.energy > bestCursorScore) {\n                    bestCursorScore = wayDown.energy;\n                    mostLikelyCursorLocation = {x, y};\n                }\n            }\n        }\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                const cellXY = this.getCellXY(x, y);\n                const centerX = cellXY.x;\n                const centerY = cellXY.y;\n\n                // WARNING: This isn't appropriately scale insensitive.\n                const D = 2;\n                //const farD = 3;\n                const center     = getPixelColor(centerX,        centerY);\n                const upLeft     = getPixelColor(centerX - D,    centerY - D);\n                const upRight    = getPixelColor(centerX + D,    centerY - D);\n                const downLeft   = getPixelColor(centerX - D,    centerY + D);\n                const downRight  = getPixelColor(centerX + D,    centerY + D);\n                const probablyInsideCursor = x === mostLikelyCursorLocation.x && y === mostLikelyCursorLocation.y;\n                // This variable says if we think our left side is likely corrupted by the cursor's halo.\n                const cursorHaloLeft  = probablyInsideCursor || x === mostLikelyCursorLocation.x + 1 && y === mostLikelyCursorLocation.y;\n                const cursorHaloRight = probablyInsideCursor || x === mostLikelyCursorLocation.x - 1 && y === mostLikelyCursorLocation.y;\n                const cursorHaloUp    = probablyInsideCursor || x === mostLikelyCursorLocation.x && y === mostLikelyCursorLocation.y + 1;\n                const cursorHaloDown  = probablyInsideCursor || x === mostLikelyCursorLocation.x && y === mostLikelyCursorLocation.y - 1;\n                const cursorHaloUL = cursorHaloUp   || cursorHaloLeft;\n                const cursorHaloUR = cursorHaloUp   || cursorHaloRight;\n                const cursorHaloDL = cursorHaloDown || cursorHaloLeft;\n                const cursorHaloDR = cursorHaloDown || cursorHaloRight;\n                \n                let color = nothingColor;\n\n                let threshold = probablyInsideCursor ? 240 : 220;\n                const passingCount = (\n                    (center.energy    >= threshold) +\n                    (upLeft.energy    >= (cursorHaloUL ? 240 : 220)) +\n                    (upRight.energy   >= (cursorHaloUR ? 240 : 220)) +\n                    (downLeft.energy  >= (cursorHaloDL ? 240 : 220)) +\n                    (downRight.energy >= (cursorHaloDL ? 240 : 220))\n                );\n                const greenerMargin = probablyInsideCursor ? 1 : 1.02;\n                const greenerThanBlueCount = (\n                    (center.g    >= center.b *    greenerMargin) +\n                    (upLeft.g    >= upLeft.b *    (cursorHaloUL ? greenerMargin : 1.05)) +\n                    (upRight.g   >= upRight.b *   (cursorHaloUR ? greenerMargin : 1.05)) +\n                    (downLeft.g  >= downLeft.b *  (cursorHaloDL ? greenerMargin : 1.05)) +\n                    (downRight.g >= downRight.b * (cursorHaloDR ? greenerMargin : 1.05))\n                );\n                // There's an obnoxious light in this cell, so we have to special case it.\n                //const disqualified = x === 4 && y === 6 && center.energy < 200;\n                resultantState.grid[[x, y]] = null;\n                if (\n                    (passingCount >= 4 && greenerThanBlueCount >= 3) || (passingCount >= 3 && greenerThanBlueCount >= 4)\n                ) {\n                    const maxRed   = Math.max(center.r, upLeft.r, upRight.r, downLeft.r, downRight.r);\n                    const maxGreen = Math.max(center.g, upLeft.g, upRight.g, downLeft.g, downRight.g);\n                    if (maxRed > maxGreen * 1.25) {\n                        color = hitColor\n                        resultantState.grid[[x, y]] = 'HIT';\n                    } else {\n                        color = missColor;\n                        resultantState.grid[[x, y]] = 'MISS';\n                    }\n                }\n                if (window.JUST_ONCE) {\n                    // Debugging code, please ignore this.\n                    if (probablyInsideCursor)\n                        console.log('INSIDE!!!!!');\n                    console.log('Scores:', x, y, probablyInsideCursor, greenerThanBlueCount, center, upLeft, upRight, downLeft, downRight);\n                }\n                let tl = new window.cv.Point(centerX - 7, centerY - 7);\n                let br = new window.cv.Point(centerX + 7, centerY + 7);\n                window.cv.rectangle(src, tl, br, color, 1, window.cv.LINE_8, 0);\n            }\n        }\n        for (let squidIndex = 0; squidIndex < 3; squidIndex++) {\n            const cellXY = this.getSquidIndicatorXY(squidIndex);\n            const centerX = cellXY.x;\n            const centerY = cellXY.y;\n            const pixelPtr = src.ucharPtr(Math.round(centerY), Math.round(centerX));\n            const pixelColor = {r: pixelPtr[0], g: pixelPtr[1], b: pixelPtr[2]};\n            let tl = new window.cv.Point(centerX - 15, centerY - 15);\n            let br = new window.cv.Point(centerX + 15, centerY + 15);\n            let color = remainingSquidColor;\n            if (pixelColor.r > pixelColor.b * 1.25) {\n                color = killedSquidColor;\n                resultantState.squidsGotten = Math.max(resultantState.squidsGotten, squidIndex + 1);\n            }\n\n            window.cv.rectangle(src, tl, br, color, 1, window.cv.LINE_8, 0);\n        }\n        const boardRect = this.getBoardRect();\n        const srcCrop = src.roi(boardRect);\n        toDelete.push(srcCrop);\n        window.cv.imshow('cv_outputCanvasRef', srcCrop);\n        for (const mat of toDelete)\n            mat.delete();\n        const t1 = performance.now();\n        console.log('CV took: ' + (t1 - t0) + 'ms');\n        this.setState({lastCVTime: t1 - t0});\n\n        function compareStatesEqual(A, B) {\n            if (A === null || B === null)\n                return false;\n            let allEqual = A.squidsGotten  === B.squidsGotten;\n            for (let y = 0; y < 8; y++)\n                for (let x = 0; x < 8; x++)\n                    if (A.grid[[x, y]] !== B.grid[[x, y]])\n                        allEqual = false;\n            return allEqual\n        }\n\n        // Only recompute if we see states of the form: ABBB (that is, three in a row for debouncing, plus a change).\n        if (\n            (!compareStatesEqual(this.previouslyReadStates[0], this.previouslyReadStates[1])) &&\n            compareStatesEqual(this.previouslyReadStates[1], this.previouslyReadStates[2]) &&\n            compareStatesEqual(this.previouslyReadStates[2], resultantState)\n        ) {\n            this.setState(resultantState);\n            await this.doComputation(resultantState.grid, resultantState.squidsGotten);\n        }\n        this.previouslyReadStates.shift();\n        this.previouslyReadStates.push(resultantState);\n\n        return resultantState;\n    }\n\n    updateCapture() {\n        const video = this.videoRef.current;\n        const canvas = this.canvasRef.current;\n        //const referenceCanvas = this.referenceCanvasRef.current;\n        //const outputCanvas = this.outputCanvasRef.current;\n        const context = canvas.getContext('2d');\n        //const width = video.width;\n        //const height = video.height;\n        const width = 960;\n        const height = Math.round(width * (video.videoHeight / video.videoWidth));\n        console.log('Native image capture shape: ' + video.videoWidth + 'x' + video.videoHeight + ' -> scaling to: ' + width + 'x' + height);\n        canvas.width = width;\n        canvas.height = height;\n        context.drawImage(video, 0, 0, width, height);\n    }\n\n    async doComputation(grid, squidsGotten) {\n        const t0 = performance.now();\n        const hits = [];\n        const misses = [];\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                const gridValue = grid[[x, y]];\n                if (gridValue === 'HIT')\n                    hits.push(8 * y + x);\n                if (gridValue === 'MISS')\n                    misses.push(8 * y + x);\n            }\n        }\n        let squids_gotten = -1;\n        for (const n of ['0', '1', '2'])\n            if (squidsGotten === n || squidsGotten === Number(n))\n                squids_gotten = Number(n);\n\n        await wasm;\n        const probabilities = calculate_probabilities(Uint8Array.from(hits), Uint8Array.from(misses), squids_gotten);\n        //console.debug(probabilities);\n\n        if (probabilities !== undefined) {\n            let maxY = 0;\n            let maxX = 0;\n            let highestProb = -1;\n            let probs = [];\n\n            for (let y = 0; y < 8; y++) {\n                for (let x = 0; x < 8; x++) {\n                    probs[[x, y]] = probabilities[8 * y + x];\n                    if (grid[[x, y]] === null && probabilities[8 * y + x] > highestProb) {\n                        highestProb = probabilities[8 * y + x];\n                        maxX = x;\n                        maxY = y;\n                    }\n                }\n            }\n            const observationProb = probabilities[64];\n            this.setState({ probs, best: highestProb >= 0 ? [maxX, maxY] : null, valid: true, observationProb });\n        }\n        const t1 = performance.now();\n        this.setState({lastComputationTime: t1 - t0});\n    }\n\n    onClick(x, y) {\n        const grid = { ...this.state.grid };\n        let gridValue = grid[[x, y]];\n        let squidsGotten = this.state.squidsGotten;\n\n        if (this.state.mode === 'calculator') {\n            switch (gridValue) {\n                case null:\n                    gridValue = 'MISS';\n                    break;\n                case 'MISS':\n                    gridValue = 'HIT';\n                    break;\n                case 'HIT':\n                    gridValue = null;\n                    break;\n            }\n            grid[[x, y]] = gridValue;\n        } else {\n            // Determine from the random layout.\n            if (gridValue !== null)\n                return;\n            const arrayContains = (arr) => {\n                for (const cell of arr)\n                    if (cell[0] === x && cell[1] === y)\n                        return true;\n                return false;\n            }\n            if (arrayContains([...this.state.squidLayout.squid2, ...this.state.squidLayout.squid3, ...this.state.squidLayout.squid4])) {\n                gridValue = 'HIT';\n            } else {\n                gridValue = 'MISS';\n            }\n            grid[[x, y]] = gridValue;\n            // Compute the killed squid count.\n            squidsGotten = 0;\n            for (const n of ['2', '3', '4']) {\n                const squid = this.state.squidLayout['squid' + n];\n                let killed = true;\n                for (const cell of squid)\n                    if (grid[cell] !== 'HIT')\n                        killed = false;\n                squidsGotten += killed;\n            }\n            this.setState({ squidsGotten });\n        }\n        this.setState({ grid });\n        this.doComputation(grid, squidsGotten);\n    }\n\n    clearField() {\n        const newState = this.makeEmptyState();\n        newState.mode = this.state.mode;\n        newState.screenRecordingActive = this.state.screenRecordingActive;\n        newState.doVideoProcessing = this.state.doVideoProcessing;\n        this.setState(newState);\n        this.doComputation(newState.grid, newState.squidsGotten);\n    }\n\n    renderActualMap(overlayMode) {\n        return <div style={{display: 'inline-block'}}>\n            {naturalsUpTo(8).map(\n                (y) => <div key={y} style={{\n                    display: 'flex',\n                }}>\n                    {naturalsUpTo(8).map(\n                        (x) => <Tile\n                            key={x + ',' + y}\n                            x={x} y={y}\n                            onClick={() => this.onClick(x, y)}\n                            text={this.state.grid[[x, y]]}\n                            prob={this.state.probs[[x, y]]}\n                            valid={this.state.valid}\n                            best={this.state.best}\n                            precision={overlayMode ? 0 : 2}\n                            opacity={overlayMode ? 0.5 + 0.3 * this.state.probs[[x, y]] : undefined}\n                        />\n                    )}\n                </div>\n            )}\n        </div>;\n    }\n\n    renderOverlayMap() {\n        if (!this.state.doVideoProcessing)\n            return;\n        return <div style={{\n            position: 'absolute',\n            top: '210px',\n            left: '127px',\n            transform: 'scale(1.01, 1.05)',\n            zIndex: 20,\n            display: 'inline-block',\n            /* opacity: 0.4, */\n        }}>\n            {this.renderActualMap(true)}\n        </div>;\n    }\n\n    render() {\n        let usedShots = 0;\n        let openingOptimizer = true;\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                if (this.state.grid[[x, y]] !== null) {\n                    usedShots++;\n                    if (this.state.grid[[x, y]] === 'HIT')\n                        openingOptimizer = false;\n                }\n            }\n        }\n        return <div style={{\n            margin: '20px',\n        }}>\n            <span style={{ fontSize: '150%', color: 'white' }}>Shots used: {usedShots}</span><br />\n            {this.state.doVideoProcessing || this.renderActualMap(false)}\n            {this.state.valid || <div style={{ fontSize: '150%', color: 'white' }}>Invalid configuration! This is not possible.</div>}\n            <br />\n            <div style={{ fontSize: '150%' }}>\n                <span style={{ color: 'white' }}>Number of squids killed:</span>\n                <select\n                    style={{ marginLeft: '20px', fontSize: '100%' }}\n                    value={this.state.squidsGotten}\n                    onChange={(event) => {\n                        this.setState({ squidsGotten: event.target.value });\n                        this.doComputation(this.state.grid, event.target.value);\n                    }}\n                >\n                    <option value=\"unknown\">Unknown</option>\n                    <option value=\"0\">0</option>\n                    <option value=\"1\">1</option>\n                    <option value=\"2\">2</option>\n                    <option value=\"3\">3</option>\n                </select>\n                <br />\n                {/*\n                <span style={{color: 'white', fontSize: '80%'}}>\n                    Probability of this pattern yielding these results: {(100 * this.state.observationProb).toFixed(2) + '%'}\n                </span>\n                */}\n            </div>\n            <br />\n            <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => { this.clearField(); }}>Reset</button>\n            <select\n                style={{ marginLeft: '20px', fontSize: '150%' }}\n                value={this.state.mode}\n                onChange={(event) => this.setState({ mode: event.target.value })}\n            >\n                <option value=\"calculator\">Calculator Mode</option>\n                <option value=\"practice\">Practice Mode</option>\n            </select><br />\n            {openingOptimizer && (!this.state.screenRecordingActive) && this.state.mode === 'calculator' && <>\n                <div style={{ color: 'white', fontSize: '120%', marginTop: '20px' }}>\n                    Opening optimizer: Probability that this<br />pattern would get at least one hit: {\n                        this.state.valid ? ((100 * Math.max(0, 1 - this.state.observationProb)).toFixed(2) + '%') : \"Invalid\"\n                    }\n                </div>\n            </>}\n            {/* <button style={{ fontSize: '150%' }} onClick={() => { this.readBoardState(); }}>Do Computation</button><br /> */}\n            <br/>\n            <hr/>\n            <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => {\n                this.startScreenRecording();\n            }}>Start Screen Cap</button>\n            <button disabled={!this.state.screenRecordingActive} style={{ fontSize: '150%', margin: '10px' }} onClick={() => {\n                this.bannerCache = new Map();\n                this.getBoardRegistrationAndScale();\n            }}>Detect Board</button>\n            <button disabled={!this.state.screenRecordingActive} style={{ fontSize: '150%', margin: '10px' }} onClick={() => {\n                this.toggleVideoProcessing();\n            }}>{this.state.doVideoProcessing ? 'Stop Processing (p)' : 'Start Processing (p)'}</button><br />\n\n            <video style={{display: 'none'}} ref={this.videoRef}>Video stream not available.</video>\n            <canvas style={{display: 'none'}} ref={this.canvasRef} id=\"cv_canvasRef\"></canvas>\n            {/* <canvas ref={this.referenceCanvasRef} id=\"cv_referenceCanvasRef\"></canvas> */}\n            <div style={{display: 'inline-block'}}>\n                <div style={{\n                    display: 'inline-block',\n                    position: 'relative',\n                }}>\n                    <canvas style={{\n                        border: this.state.doVideoProcessing ? '5px solid red' : '5px solid blue',\n                        width: '1000px',\n                    }} ref={this.outputCanvasRef} id=\"cv_outputCanvasRef\"></canvas>\n                    {this.renderOverlayMap()}\n                </div>\n            </div>\n            <br/>\n            <span style={{ color: 'white' }}>Last CV time: {this.state.lastCVTime}ms - Last recompute time: {this.state.lastComputationTime}ms</span>\n            <div style={{display: 'none'}} ref={this.hiddenAreaRef}></div>\n        </div>;\n    }\n}\n\nfunction globalShortcutsHandler(evt) {\n    if (evt.key === 'p' && globalMap !== null)\n        globalMap.toggleVideoProcessing();\n}\n\ndocument.addEventListener('keydown', globalShortcutsHandler);\n\nclass App extends React.Component {\n    componentDidMount() {\n        document.body.style.backgroundColor = '#666';\n        /*\n        const opencvScript = document.createElement('script');\n        opencvScript.addEventListener('load', )\n        opencvScript.setAttribute('src', '');\n        */\n    }\n\n    render() {\n        return <div style={{\n            textAlign: 'center',\n        }}>\n            <div style={{ display: 'inline-block', width: '600px' }}>\n                <h1 style={{ color: 'white' }}>Sploosh Kaboom Probability Calculator</h1>\n                <p style={{ color: 'white' }}>\n                    This page gives exact probabilities (no approximation) of hitting a squid in each cell, given the observation of hits, misses, and completed squid kills.\n                    Click on the map to cycle a cell between HIT and MISS.\n                    You can also set the number of squids completely killed in the drop-down menu at the bottom.\n                    You should set this to the value you see in the game for the number of squids killed.\n                    This will yield slightly more accurate probabilities.\n                    The highest probability location to play will be shown with a yellow outline.\n                    If you play perfectly according to picking the highlighted cell you will win in 20 or fewer shots ≈18.5% of the time.\n                </p>\n            </div>\n            <MainMap />\n            <span style={{ color: 'white' }}>Made by Peter Schmidt-Nielsen and CryZe (v0.0.2)</span>\n        </div>;\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
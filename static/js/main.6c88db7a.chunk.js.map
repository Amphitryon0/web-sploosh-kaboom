{"version":3,"sources":["wasm/sploosh_wasm.js","App.js","serviceWorker.js","index.js"],"names":["wasm","cachegetUint8Memory0","WASM_VECTOR_LEN","passArray8ToWasm0","arg","malloc","ptr","length","buffer","memory","Uint8Array","set","cachegetUint32Memory0","passArray32ToWasm0","Uint32Array","cachegetFloat64Memory0","getFloat64Memory0","Float64Array","passArrayF64ToWasm0","cachegetInt32Memory0","getInt32Memory0","Int32Array","getArrayF64FromWasm0","len","subarray","calculate_probabilities_with_board_constraints","hits","misses","squids_gotten","board_constraints","constraint_probs","ptr0","__wbindgen_malloc","len0","ptr1","len1","ptr2","len2","ptr3","len3","v4","r0","r1","slice","__wbindgen_free","calculate_probabilities_from_game_history","observed_boards","prior_steps_from_previous_means","prior_steps_from_previous_stddevs","ptr4","len4","v5","disambiguate_final_board","undefined","set_board_table","board_table","load","module","imports","a","Response","WebAssembly","instantiateStreaming","headers","get","console","warn","arrayBuffer","bytes","instantiate","instance","Instance","init","input","Request","URL","fetch","exports","__wbindgen_wasm_module","interpolate","require","globalDB","indexedDBreq","window","indexedDB","open","dbWrite","key","value","transaction","oncomplete","event","onerror","alert","objectStore","add","onsuccess","dbRead","Promise","resolve","reject","request","target","result","errorCode","onupgradeneeded","createObjectStore","colormap","naturalsUpTo","n","Array","keys","Tile","isBest","this","props","best","x","y","backgroundColor","text","prob","style","display","justifyContent","alignItems","textAlign","width","height","border","valid","outline","zIndex","fontFamily","userSelect","MozUserSelect","WebkitUserSelect","msUserSelect","color","fontSize","opacity","onClick","toFixed","precision","React","Component","process","JUST_ONCE","globalMap","dbCachedFetch","url","callback","cacheMiss","req","XMLHttpRequest","responseType","onload","evt","response","send","catch","makeBoardIndicesTable","actuallyMakeBoardIndicesTable","descs","direction","push","allBoards","boardIndices","placeSquid","board","desc","i","fill","squid2","squid3","squid4","count","from","index","map","join","sampleSquid","Math","round","random","cells","cell","newXY","LayoutDrawingBoard","state","grid","makeEmptyGrid","selectedCell","setState","changeMade","dx","dy","countsBySquid","2","3","4","layoutString","getLayoutString","boardIndex","parent","isSelectedCell","margin","backgroundImage","backgroundSize","padding","globalBoardTimer","setInterval","forceUpdate","BoardTimer","previouslyAccumulatedSeconds","timerStartMS","timerRunning","includesLoadingTheRoom","includedRewardsGotten","invalidated","now","performance","elapsed","delta","max","min","total","timeDeltaSeconds","prediction","Number","roomEnteredOffset","getSecondsElapsed","guessStepsElapsedFromTime","textShadow","MainMap","videoRef","createRef","canvasRef","outputCanvasRef","hiddenAreaRef","layoutDrawingBoardRefs","timerRef","makeEmptyState","bannerCache","Map","RECOMP","getBoardRegistrationAndScale","previouslyReadStates","makeReferenceImageCanvases","doComputation","squidsGotten","hiddenArea","current","referenceCanvases","name","newCanvas","document","createElement","setAttribute","appendChild","newImage","src","getContext","drawImage","probs","mode","squidLayout","layout","hitLocations","candidate","isAdmissible","generateLayout","undoBuffer","observationProb","screenRecordingActive","doVideoProcessing","lastComputationTime","lastCVTime","turboBlurboMode","turboBlurboTiming","showKeyShortcuts","timerStepEstimate","potentialMatches","firstBoardStepsThousands","firstBoardStepsThousandsStdDev","nextBoardStepsThousands","nextBoardStepsThousandsStdDev","timedBoardStepsThousandsStdDev","displayMediaOptions","video","cursor","audio","navigator","mediaDevices","getDisplayMedia","captureStream","srcObject","play","setTimeout","updateCapture","canvas","outputCanvas","log","bigTable","boardIndexToLayoutString","Object","buf","boardTable","v","readyToProcess","resultantState","bestGuessScale","searchMargin","performGridSearch","boardFitParams","scale","delete","testForTopBannerAtScale","testForBottomBanner","sampleCount","bestParams","score","testScale","params","cv","imread","base_templ","scaled_banner_width","size","scaled_banner_height","templ","Mat","dsize","Size","resize","INTER_AREA","dst","mask","matchMode","TM_CCOEFF_NORMED","matchTemplate","maxPoint","minMaxLoc","maxLoc","Scalar","point","Point","cols","rows","rectangle","LINE_8","imshow","bottomBannerOffset","aspectRatioFactor","topBannerOffset","Rect","has","maxVal","hasOwnProperty","compareStatesEqual","A","B","allEqual","t0","ksize","GaussianBlur","BORDER_DEFAULT","toDelete","getPixelColor","pixelPtr","ucharPtr","pixelColor","r","g","b","energy","sqrt","nothingColor","hitColor","missColor","killedSquidColor","remainingSquidColor","mostLikelyCursorLocation","bestCursorScore","cellXY","getCellXY","wayDown","centerX","centerY","center","upLeft","upRight","downLeft","downRight","probablyInsideCursor","cursorHaloLeft","cursorHaloRight","cursorHaloUp","cursorHaloDown","cursorHaloUL","cursorHaloUR","cursorHaloDL","cursorHaloDR","threshold","passingCount","greenerMargin","greenerThanBlueCount","maxRed","maxGreen","tl","br","squidIndex","getSquidIndicatorXY","boardRect","getBoardRect","srcCrop","roi","t1","shift","context","videoHeight","videoWidth","observedBoards","startIndex","scanRange","soughtBoard","indexMax","findMatchingLocations","subResult","makeGameHistoryArguments","matches","match","rawObservedBoards","ref","ob","priorStepsFromPreviousMeans","priorStepsFromPreviousStdDevs","first","gridValue","numericSquidsGotten","getGridStatistics","gameHistoryArguments","probabilities","maxY","maxX","highestProb","distanceAdjustedProb","setAsHit","copyToUndoBuffer","arr","arrayContains","squid","killed","templateState","newState","undoEntry","pop","incrementKills","boardTimer","numericValue","splitTimer","copyToHistory","finalBoard","fillIndex","shiftHistory","setStateFromLayoutString","drawingBoards","clearBoard","overlayMode","justifySelf","position","top","left","transform","renderActualMap","usedShots","openingOptimizer","className","alignSelf","gridTemplateColumns","marginLeft","onChange","reportMiss","reportHit","clearField","borderRadius","type","checked","marginTop","minHeight","diffs","recomputePotentialMatches","disabled","initializeTurboBlurboMode","addEventListener","toggleVideoProcessing","ctrlKey","undoLastMarking","toggleRunning","preventDefault","adjustRewards","toggleLoadingTheRoom","toggleInvalidated","resetTimer","App","body","href","Boolean","location","hostname","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","then","registration","unregister","error","message"],"mappings":"wMACIA,E,kIAEAC,G,MAAuB,MAQ3B,IAAIC,EAAkB,EAEtB,SAASC,EAAkBC,EAAKC,GAC5B,IAAMC,EAAMD,EAAoB,EAAbD,EAAIG,QAGvB,OAZ6B,OAAzBN,GAAiCA,EAAqBO,SAAWR,EAAKS,OAAOD,SAC7EP,EAAuB,IAAIS,WAAWV,EAAKS,OAAOD,SAE/CP,GAOWU,IAAIP,EAAKE,EAAM,GACjCJ,EAAkBE,EAAIG,OACfD,EAGX,IAAIM,EAAwB,KAQ5B,SAASC,EAAmBT,EAAKC,GAC7B,IAAMC,EAAMD,EAAoB,EAAbD,EAAIG,QAGvB,OAV8B,OAA1BK,GAAkCA,EAAsBJ,SAAWR,EAAKS,OAAOD,SAC/EI,EAAwB,IAAIE,YAAYd,EAAKS,OAAOD,SAEjDI,GAKYD,IAAIP,EAAKE,EAAM,GAClCJ,EAAkBE,EAAIG,OACfD,EAGX,IAAIS,EAAyB,KAC7B,SAASC,IAIL,OAH+B,OAA3BD,GAAmCA,EAAuBP,SAAWR,EAAKS,OAAOD,SACjFO,EAAyB,IAAIE,aAAajB,EAAKS,OAAOD,SAEnDO,EAGX,SAASG,EAAoBd,EAAKC,GAC9B,IAAMC,EAAMD,EAAoB,EAAbD,EAAIG,QAGvB,OAFAS,IAAoBL,IAAIP,EAAKE,EAAM,GACnCJ,EAAkBE,EAAIG,OACfD,EAGX,IAAIa,EAAuB,KAC3B,SAASC,IAIL,OAH6B,OAAzBD,GAAiCA,EAAqBX,SAAWR,EAAKS,OAAOD,SAC7EW,EAAuB,IAAIE,WAAWrB,EAAKS,OAAOD,SAE/CW,EAGX,SAASG,EAAqBhB,EAAKiB,GAC/B,OAAOP,IAAoBQ,SAASlB,EAAM,EAAGA,EAAM,EAAIiB,GAUpD,SAASE,EAA+CC,EAAMC,EAAQC,EAAeC,EAAmBC,GAC3G,IAAIC,EAAO5B,EAAkBuB,EAAM1B,EAAKgC,mBACpCC,EAAO/B,EACPgC,EAAO/B,EAAkBwB,EAAQ3B,EAAKgC,mBACtCG,EAAOjC,EACPkC,EAAOvB,EAAmBgB,EAAmB7B,EAAKgC,mBAClDK,EAAOnC,EACPoC,EAAOpB,EAAoBY,EAAkB9B,EAAKgC,mBAClDO,EAAOrC,EACXF,EAAKyB,+CAA+C,EAAGM,EAAME,EAAMC,EAAMC,EAAMP,EAAeQ,EAAMC,EAAMC,EAAMC,GAChH,IAEIC,EAFAC,EAAKrB,IAAkB,GACvBsB,EAAKtB,IAAkB,GAM3B,OAJW,IAAPqB,IACAD,EAAKlB,EAAqBmB,EAAIC,GAAIC,QAClC3C,EAAK4C,gBAAgBH,EAAS,EAALC,IAEtBF,EAYJ,SAASK,EAA0CnB,EAAMC,EAAQC,EAAekB,EAAiBC,EAAiCC,GACrI,IAAIjB,EAAO5B,EAAkBuB,EAAM1B,EAAKgC,mBACpCC,EAAO/B,EACPgC,EAAO/B,EAAkBwB,EAAQ3B,EAAKgC,mBACtCG,EAAOjC,EACPkC,EAAOvB,EAAmBiC,EAAiB9C,EAAKgC,mBAChDK,EAAOnC,EACPoC,EAAOzB,EAAmBkC,EAAiC/C,EAAKgC,mBAChEO,EAAOrC,EACP+C,EAAO/B,EAAoB8B,EAAmChD,EAAKgC,mBACnEkB,EAAOhD,EACXF,EAAK6C,0CAA0C,EAAGd,EAAME,EAAMC,EAAMC,EAAMP,EAAeQ,EAAMC,EAAMC,EAAMC,EAAMU,EAAMC,GACvH,IAEIC,EAFAV,EAAKrB,IAAkB,GACvBsB,EAAKtB,IAAkB,GAM3B,OAJW,IAAPqB,IACAU,EAAK7B,EAAqBmB,EAAIC,GAAIC,QAClC3C,EAAK4C,gBAAgBH,EAAS,EAALC,IAEtBS,EAUJ,SAASC,EAAyB1B,EAAMoB,EAAiBC,EAAiCC,GAC7F,IAAIjB,EAAO5B,EAAkBuB,EAAM1B,EAAKgC,mBACpCC,EAAO/B,EACPgC,EAAOrB,EAAmBiC,EAAiB9C,EAAKgC,mBAChDG,EAAOjC,EACPkC,EAAOvB,EAAmBkC,EAAiC/C,EAAKgC,mBAChEK,EAAOnC,EACPoC,EAAOpB,EAAoB8B,EAAmChD,EAAKgC,mBACnEO,EAAOrC,EACXF,EAAKoD,yBAAyB,EAAGrB,EAAME,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,GAC3E,IAAIE,EAAKrB,IAAkB,GACvBsB,EAAKtB,IAAkB,GAC3B,OAAc,IAAPqB,OAAWY,EAAYX,IAAO,EAMlC,SAASY,EAAgBC,GAC5B,IAAIxB,EAAOlB,EAAmB0C,EAAavD,EAAKgC,mBAC5CC,EAAO/B,EACXF,EAAKsD,gBAAgBvB,EAAME,G,SAGhBuB,E,gFAAf,WAAoBC,EAAQC,GAA5B,iBAAAC,EAAA,2DAC4B,oBAAbC,UAA2BH,aAAkBG,UAD5D,oBAGwD,oBAArCC,YAAYC,qBAH/B,0CAK6BD,YAAYC,qBAAqBL,EAAQC,GALtE,2EAQ0D,oBAAtCD,EAAOM,QAAQC,IAAI,gBARvC,iBASoBC,QAAQC,KAAK,oMAAb,MATpB,4DAiB4BT,EAAOU,cAjBnC,eAiBcC,EAjBd,iBAkBqBP,YAAYQ,YAAYD,EAAOV,GAlBpD,kEAsB+BG,YAAYQ,YAAYZ,EAAQC,GAtB/D,cAsBcY,EAtBd,kBAwBgCT,YAAYU,UAxB5C,0CAyBmB,CAAED,WAAUb,WAzB/B,iCA4BmBa,GA5BnB,0D,+BAiCeE,E,8EAAf,WAAoBC,GAApB,qBAAAd,EAAA,6DAIUD,EAAU,IAGK,kBAAVe,GAA0C,oBAAZC,SAA0BD,aAAiBC,SAA4B,oBAARC,KAAsBF,aAAiBE,OAC3IF,EAAQG,MAAMH,IARtB,KAWuCjB,EAXvC,SAWkDiB,EAXlD,+BAWyDf,EAXzD,oDAWYY,EAXZ,EAWYA,SAAUb,EAXtB,EAWsBA,OAElBzD,EAAOsE,EAASO,QAChBL,EAAKM,uBAAyBrB,EAdlC,kBAgBWzD,GAhBX,6C,sBAmBewE,QCnMTO,EAAcC,EAAQ,IAExBC,EAAW,KACTC,EAAeC,OAAOC,UAAUC,KAAK,gBAAiB,GAoB5D,SAASC,EAAQC,EAAKC,GAClB,GAAiB,OAAbP,EAAJ,CAGA,IAAMQ,EAAcR,EAASQ,YAAY,CAAC,MAAO,aAEjDA,EAAYC,WAAa,SAASC,KAGlCF,EAAYG,QAAU,SAASD,GAC3BE,MAAM,uBAEUJ,EAAYK,YAAY,MAChBC,IAAIP,EAAOD,GAC/BS,UAAY,SAASL,MAKjC,SAASM,EAAOV,GACZ,OAAO,IAAIW,SAAQ,SAACC,EAASC,GACzB,IAAMX,EAAcR,EAASQ,YAAY,CAAC,OAE1CA,EAAYC,WAAa,SAASC,KAGlCF,EAAYG,QAAU,SAASD,GAC3BE,MAAM,uBAEV,IACMQ,EADcZ,EAAYK,YAAY,MAChB9B,IAAIuB,GAChCc,EAAQL,UAAY,SAASL,GAEzBQ,EAAQR,EAAMW,OAAOC,SAEzBF,EAAQT,QAAU,SAASD,GAEvBS,QAxDZlB,EAAaU,QAAU,SAASD,GAC5BE,MAAM,gCAIVX,EAAac,UAAY,SAASL,IAC9BV,EAAWU,EAAMW,OAAOC,QACfX,QAAU,SAASD,GACxBE,MAAM,oBAAsBF,EAAMW,OAAOE,aAGjDtB,EAAauB,gBAAkB,SAASd,GACzBA,EAAMW,OAAOC,OACrBG,kBAAkB,OAoDzB,IAAMC,EAAW5B,EAAY,CAAC,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,SACxE6B,EAAe,SAACC,GAAD,mBAAWC,MAAMD,GAAGE,SAEnCC,E,uKAEE,IAAMC,EAA6B,OAApBC,KAAKC,MAAMC,MAAiBF,KAAKC,MAAMC,KAAK,KAAOF,KAAKC,MAAME,GAAKH,KAAKC,MAAMC,KAAK,KAAOF,KAAKC,MAAMG,EAEhHC,EAAkBL,KAAKC,MAAMI,gBAOjC,YANwBlE,IAApBkE,IACAA,EAAsC,OAApBL,KAAKC,MAAMK,KAAgBb,EAASO,KAAKC,MAAMM,MACzC,QAApBP,KAAKC,MAAMK,KAAiB,OAAS,QAItC,yBACHjC,IAAK2B,KAAKC,MAAME,EAAI,IAAMH,KAAKC,MAAMG,EACrCI,MAAO,CACHC,QAAS,OACTC,eAAgB,SAChBC,WAAY,SACZC,UAAW,SACXC,MAAO,OACPC,OAAQ,OACRC,OAAQf,KAAKC,MAAMe,MAAQ,iBAAmB,gBAC9CC,QAASlB,EAAS,mBAAqB,GACvCmB,OAAQnB,EAAS,EAAI,EACrBoB,WAAY,YACZC,WAAY,OACZC,cAAe,OACfC,iBAAkB,OAClBC,aAAc,OACdC,MAAO,QACPC,SAAUzB,KAAKC,MAAMwB,SACrBC,QAAS1B,KAAKC,MAAMyB,QACpBrB,mBAEJsB,QAAS3B,KAAKC,MAAM0B,SAEC,OAApB3B,KAAKC,MAAMK,MAAmC,IAAlBN,KAAKC,MAAMM,MAAYqB,QAAQ5B,KAAKC,MAAM4B,WAAa,IAAM7B,KAAKC,MAAMK,U,GAnC9FwB,IAAMC,WAwCrBjJ,EAAOwE,EAAK0E,4CAGhB/D,OAAOgE,WAAY,EAGnB,IAAIC,EAAY,K,SAgBDC,E,gFAAf,WAA6BC,EAAKC,GAAlC,IACaC,EADb,WAAA7F,EAAA,6DACa6F,EADb,WAEQ,IAAMC,EAAM,IAAIC,eAQhB,OAPAD,EAAIpE,KAAK,MAAO6D,sBAAyBI,GAAK,GAC9CG,EAAIE,aAAe,cACnBF,EAAIG,OAAS,SAACC,GACVvE,EAAQgE,EAAKG,EAAIK,UACjBP,EAASE,EAAIK,WAEjBL,EAAIM,OACG,MAVf,SAYyB9D,EAAOqD,GAAKU,MAAMR,GAZ3C,eAamBnG,KADTkD,EAZV,+BAcQiD,IAdR,6BAmBmB,OAAXjD,EAnBR,iDAqBIgD,EAAShD,GArBb,6C,+BAwBe0D,I,2EAAf,iBACaT,EADb,WAAA7F,EAAA,6DACa6F,EADb,WAEQ,IAAMjD,EAAS2D,KAEf,OADA5E,EAAQ,oBAAqBiB,GACtBA,GAJf,SAMyBN,EAAO,qBAAqB+D,MAAMR,GAN3D,eAOmBnG,KADTkD,EANV,iDAQeiD,KARf,gCASWjD,GATX,4C,sBAYA,SAAS2D,KAGL,IADA,IAAMC,EAAQ,GACL7C,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACnB,cAAwB,EAAC,GAAO,GAAhC,gBAAK,IAAM+C,EAAS,KAChBD,EAAME,KAAK,CAAChD,IAAGC,IAAG8C,cAC9B,IAAME,EAAY,GACZC,EAAe,GACrB,SAASC,EAAWC,EAAOC,EAAMnK,GAC7B,IAAK,IAAIoK,EAAI,EAAGA,EAAIpK,EAAQoK,IAAK,CAAC,IACzBtD,EAAQqD,EAARrD,EAAGC,EAAKoD,EAALpD,EAMR,GALIoD,EAAKN,UACL/C,GAAKsD,EAELrD,GAAKqD,EAELtD,GAAK,GAAKC,GAAK,EACf,OACJmD,EAHcpD,EAAI,EAAIC,GAGP/G,GAKvB,IAFA,IAAMkK,EAAQ,IAAI3D,MAAM,IAAI8D,KAAK,GAEjC,MAAqBT,EAArB,eAA4B,CAAvB,IAAuB,EAAjBU,EAAM,KAAW,cACHV,GADG,IACxB,2BAA4B,CAAC,IAAD,EAAjBW,EAAiB,sBACHX,GADG,IACxB,2BAA4B,CAAC,IAAlBY,EAAiB,QACxBN,EAAMG,KAAK,GACXJ,EAAWC,EAAOI,EAAQ,GAC1BL,EAAWC,EAAOK,EAAQ,GAC1BN,EAAWC,EAAOM,EAAQ,GAC1B,IALwB,EAKpBC,EAAQ,EALY,cAMJP,GANI,IAMxB,4BACIO,GADJ,SANwB,8BAQV,KAAVA,GAEJV,EAAUD,KAAKvD,MAAMmE,KAAKR,KAXN,gCADJ,+BAiB5B,IADA,IAAIS,EAAQ,EACZ,MAAoBZ,EAApB,eAA+B,CAC3BC,EADY,KACOY,KAAI,SAACR,GAAD,OAAa,IAANA,EAAU,IAAMA,KAAGS,KAAK,KAAOF,EAC7DA,IAEJ,OAAOX,EAQX,SAASc,GAAY9K,GAKjB,IAJA,IAAM8G,EAAIiE,KAAKC,MAAsB,EAAhBD,KAAKE,UACpBlE,EAAIgE,KAAKC,MAAsB,EAAhBD,KAAKE,UACpBpB,EAAYkB,KAAKE,SAAW,GAC5BC,EAAQ,CAAC,CAACpE,EAAGC,IACVqD,EAAI,EAAGA,EAAIpK,EAAS,EAAGoK,IAAK,CACjC,IAAMe,EAAOD,EAAMA,EAAMlL,OAAS,GAC5BoL,EAAQvB,EAAY,CAACsB,EAAK,GAAK,EAAGA,EAAK,IAAM,CAACA,EAAK,GAAIA,EAAK,GAAK,GACvED,EAAMpB,KAAKsB,GAEf,OAAOF,EAfNtG,OAAOgE,U,IAuCNyC,G,kDACF,aAAe,IAAD,8BACV,gBACKC,MAAQ,CAAEC,KAAM,EAAKC,gBAAiBC,aAAc,MAF/C,E,4DAOV,IADA,IAAMF,EAAO,GACJxE,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACnByE,EAAK,CAACzE,EAAGC,IAAM,IACvB,OAAOwE,I,mCAIP5E,KAAK+E,SAAS,CAAEH,KAAM5E,KAAK6E,gBAAiBC,aAAc,S,8BAGtD3E,EAAGC,GACP,GAAgC,OAA5BJ,KAAK2E,MAAMG,aAAf,CAMA,IAFA,IAAMF,EAAI,eAAO5E,KAAK2E,MAAMC,MACxBI,GAAa,EACjB,MAAqB,CAAC,EAAG,EAAG,GAA5B,eACI,IADC,IAAM3L,EAAM,KACb,MAAuB,CAAC,CAAC,EAAI,GAAI,CAAC,EAAG,GAAK,EAAE,EAAG,GAAI,CAAC,GAAI,IAAxD,eAA6D,CAAC,IAAD,sBAAjD4L,EAAiD,KAA7CC,EAA6C,KACzD,GAAIlF,KAAK2E,MAAMG,aAAa,KAAO3E,EAAI8E,GAAM5L,EAAS,IAAM2G,KAAK2E,MAAMG,aAAa,KAAO1E,EAAI8E,GAAM7L,EAAS,GAAI,CAE9G,IAAK,IAAI+G,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACfyE,EAAK,CAACzE,EAAGC,MAAQ,GAAK/G,IACtBuL,EAAK,CAACzE,EAAGC,IAAM,KAE3B,IAAK,IAAIqD,EAAI,EAAGA,EAAIpK,EAAQoK,IACxBmB,EAAK,CAACzE,EAAIsD,EAAIwB,EAAI7E,EAAIqD,EAAIyB,IAAO,GAAK7L,EAC1C2L,GAAa,GAMzB,IADA,IAAMG,EAAgB,CAACC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAG,IAAK,GACrClF,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACnBgF,EAAcP,EAAK,CAACzE,EAAGC,OAC/B,cAAqB,CAAC,EAAG,EAAG,GAA5B,gBAAK,IAAM/G,EAAM,KACb,GAAI8L,EAAc9L,KAAYA,EAC1B,IAAK,IAAI+G,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACfyE,EAAK,CAACzE,EAAGC,MAAQ,GAAK/G,IACtBuL,EAAK,CAACzE,EAAGC,IAAM,KAC/B4E,GACAhF,KAAK+E,SAAS,CAAEH,SACpB5E,KAAK+E,SAAS,CAAED,aAAc,YAjC1B9E,KAAK+E,SAAS,CAAED,aAAc,CAAC3E,EAAGC,O,wCAuCtC,IADA,IAAImF,EAAe,GACVnF,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACnBoF,GAAgBvF,KAAK2E,MAAMC,KAAK,CAACzE,EAAGC,IAC5C,OAAOmF,I,+CAGcA,GAErB,IADA,IAAMX,EAAO,GACJxE,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACnByE,EAAK,CAACzE,EAAGC,IAAMmF,EAAapF,EAAI,EAAIC,GAC5CJ,KAAK+E,SAAS,CAACH,W,+BAGT,IAAD,OACCW,EAAevF,KAAKwF,kBACtBC,EAAazF,KAAKC,MAAMyF,OAAOrC,aAAakC,QAC7BpJ,IAAfsJ,IACAA,EAAa,cAEjB,IAAME,EAAiB,SAACxF,EAAGC,GAAJ,OAAsC,OAA5B,EAAKuE,MAAMG,cAAyB3E,IAAM,EAAKwE,MAAMG,aAAa,IAAM1E,IAAM,EAAKuE,MAAMG,aAAa,IAEvI,OAAO,yBAAKtE,MAAO,CACfoF,OAAQ,OACRnF,QAAS,eACTe,MAAO,UAEP,yBAAKhB,MAAO,CACRqF,gBAAiB,yDACjBC,eAAgB,YAChBC,QAAS,SAERrG,EAAa,GAAGuE,KACb,SAAC7D,GAAD,OAAO,yBAAK/B,IAAK+B,EAAGI,MAAO,CACvBC,QAAS,SAERf,EAAa,GAAGuE,KACb,SAAC9D,GAAD,OAAO,kBAAC,EAAD,CACH9B,IAAK8B,EAAI,IAAMC,EACfD,EAAGA,EAAGC,EAAGA,EACTuB,QAAS,kBAAM,EAAKA,QAAQxB,EAAGC,IAC/BE,KAAM,EAAKqE,MAAMC,KAAK,CAACzE,EAAGC,IAC1BY,OAAO,EACPd,KAAM,EAAKyE,MAAMG,aACjBrD,SAAU,OACVC,QAASiE,EAAexF,EAAGC,IAAkC,MAA5B,EAAKuE,MAAMC,KAAK,CAACzE,EAAGC,IAAc,GAAM,GACzEC,gBAA6C,MAA5B,EAAKsE,MAAMC,KAAK,CAACzE,EAAGC,SAAcjE,EAAY,kBAK7E,6BA7BH,iBA8BYsJ,O,GA/GM3D,IAAMC,WAoHnCiE,GAAmB,KAEvBC,aACI,WAC6B,OAArBD,IACAA,GAAiBE,gBAEzB,I,IASEC,G,kDACF,aAAe,IAAD,6BACV,eACAH,GAAgB,eAChB,EAAKrB,MAAQ,CACTyB,6BAA8B,EAE9BC,aAAc,EACdC,cAAc,EACdC,wBAAwB,EAExBC,sBAAuB,EACvBC,aAAa,GAXP,E,4DAgBV,IAAMC,EAAMC,YAAYD,MAClBE,EAAU,MAAQF,EAAM1G,KAAK2E,MAAM0B,cACrCrG,KAAK2E,MAAM2B,cACXtG,KAAK+E,SAAS,CAACqB,6BAA8BpG,KAAK2E,MAAMyB,6BAA+BQ,IAC3F5G,KAAK+E,SAAS,CAACuB,cAAetG,KAAK2E,MAAM2B,aAAcD,aAAcK,M,oCAG3DG,GACV7G,KAAK+E,SAAS,CAACyB,sBAAuBpC,KAAK0C,IAAI,EAAG1C,KAAK2C,IAAI,EAAG/G,KAAK2E,MAAM6B,sBAAwBK,Q,6CAIjG7G,KAAK+E,SAAS,CAACwB,wBAAyBvG,KAAK2E,MAAM4B,2B,0CAInDvG,KAAK+E,SAAS,CAAC0B,aAAczG,KAAK2E,MAAM8B,gB,mCAWxCzG,KAAK+E,SAAS,CACVqB,6BAA8B,EAC9BC,aAAcM,YAAYD,MAC1BJ,cAAc,M,0CAKlB,IAAIU,EAAQhH,KAAK2E,MAAMyB,6BACnBpG,KAAK2E,MAAM2B,eAEXU,GAAS,MADGL,YAAYD,MACD1G,KAAK2E,MAAM0B,eAEtC,OAAOW,I,gDAGeC,GAEtB,IAAIC,EAAa,IAAM,IAAMD,EAI7B,OAHIjH,KAAK2E,MAAM4B,yBACXW,IAAe,IAAMC,OAAOnH,KAAKC,MAAMmH,oBAC3CF,GAAiD,IAAnClH,KAAK2E,MAAM6B,sBAClBpC,KAAKC,MAAM6C,K,+BAIlB,IAAMN,EAAU5G,KAAKqH,oBACrB,OAAIrH,KAAK2E,MAAM8B,YACJ,oCACH,0BAAMjG,MAAO,CAAEiB,SAAU,OAAQD,MAAO,QAASL,WAAY,cAA7D,SACA,0BAAMX,MAAO,CAAEiB,SAAU,OAAQD,MAAO,QAASL,WAAY,cAA7D,gBAED,oCACH,uDACA,qCAAayF,EAAQhF,QAAQ,GAA7B,QACA,gDACA,qCAAa5B,KAAKsH,0BAA0BV,GAA5C,QACA,mDACA,qCAAyB5G,KAAK2E,MAAM4B,uBAtFxC,0BAAM/F,MAAO,CAACgB,MAAO,QAAS+F,WAAY,sBAA1C,OACA,0BAAM/G,MAAO,CAACgB,MAAO,MAAO+F,WAAY,sBAAxC,MAqFI,QACA,yDACA,qCAAavH,KAAK2E,MAAM6B,sBAAxB,a,GApFa1E,IAAMC,WA0FzByF,G,kDASF,aAAe,IAAD,8BACV,gBATJC,SAAW3F,IAAM4F,YAQH,EAPdC,UAAY7F,IAAM4F,YAOJ,EALdE,gBAAkB9F,IAAM4F,YAKV,EAJdG,cAAgB/F,IAAM4F,YAIR,EAHdI,uBAAyB,CAAChG,IAAM4F,YAAa5F,IAAM4F,YAAa5F,IAAM4F,aAGxD,EAFdK,SAAWjG,IAAM4F,YAIb,EAAK/C,MAAQ,EAAKqD,iBAClB,EAAKC,YAAc,IAAIC,IACvBjK,OAAOkK,OAAS,WACZ,EAAKF,YAAc,IAAIC,IACvB,EAAKE,gCAETlG,EAAS,eACT,EAAKmG,qBAAuB,CAAC,KAAM,KAAM,MAT/B,E,gEAaVrI,KAAKsI,6BACLtI,KAAKuI,cAAcvI,KAAK2E,MAAMC,KAAM5E,KAAK2E,MAAM6D,gB,mDAIrB,IAAD,OACnBC,EAAazI,KAAK6H,cAAca,QACtC1I,KAAK2I,kBAAoB,GAEzB,IAJyB,iBAIpB,IAAMC,EAAI,KACLC,EAAYC,SAASC,cAAc,UACzCF,EAAUG,aAAa,KAAM,UAAYJ,GACzCH,EAAWQ,YAAYJ,GAEvB,IAAMK,EAAWJ,SAASC,cAAc,OACxCG,EAASC,IAAMnH,8BAAsC4G,EAAO,OAC5DM,EAASxG,OAAS,WACdmG,EAAUhI,MAAQb,KAAKa,MACvBgI,EAAU/H,OAASd,KAAKc,OACZ+H,EAAUO,WAAW,MAC7BC,UAAUH,EAAU,EAAG,IAE/B,EAAKP,kBAAkBC,GAAQC,GAbnC,MAAmB,CAAC,MAAO,OAAQ,eAAgB,kBAAmB,iBAAkB,qBAAxF,eAA+G,M,sCAmB/G,IADA,IAAMjE,EAAO,GACJxE,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACnByE,EAAK,CAACzE,EAAGC,IAAM,KACvB,OAAOwE,I,uCAKP,IADA,IAAM0E,EAAQ,GACLlJ,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACnBmJ,EAAM,CAACnJ,EAAGC,IAAM,EAGxB,MAAO,CACHmJ,KAAM,aACNC,YApTZ,WAGI,IAFA,IAAMC,EAAS,GACTC,EAAe,GACrB,MAAgB,CAAC,EAAG,EAAG,GAAvB,eACI,IADC,IAAM/J,EAAC,OACK,CACT,IADS,EACHgK,EAAYxF,GAAYxE,GAC1BiK,GAAe,EAFV,cAGUD,GAHV,IAGT,gCAAWnF,EAAX,SACQA,EAAK,GAAK,GAAKA,EAAK,GAAK,IAA4B,IAAvBkF,EAAalF,MAC3CoF,GAAe,IALd,8BAMT,GAAIA,EAAc,CACdH,EAAO,QAAU9J,GAAKgK,EADR,oBAEKA,GAFL,IAEd,4BACID,EADJ,UACyB,GAHX,8BAId,OAIZ,OAAOD,EA+RiBI,GAIhBjF,KAAM5E,KAAK6E,gBACX2D,aAAc,UACdsB,WAAY,GACZR,QACApJ,KAAM,CAAC,EAAG,GACVc,OAAO,EACP+I,gBAAiB,EACjBC,uBAAuB,EACvBC,mBAAmB,EACnBC,qBAAsB,EACtBC,YAAa,EAEbC,iBAAiB,EACjBC,mBAAmB,EACnBC,kBAAkB,EAElBC,kBAAmB,KAEnBC,iBAAkB,GAClBC,yBAA0B,IAC1BC,+BAAgC,IAChCC,wBAAyB,EACzBC,8BAA+B,EAC/BC,+BAAgC,GAChCzD,kBAAmB,K,yKAKnBpH,KAAK2E,MAAMqF,sB,uBACXrL,MAAM,6B,iCAGJmM,EAAsB,CACxBC,MAAO,CACLC,OAAQ,UAEVC,OAAO,G,SAEiBC,UAAUC,aAAaC,gBAAgBN,G,cAA7DO,E,QACAN,EAAQ/K,KAAKyH,SAASiB,SACtB4C,UAAYD,EAClBN,EAAMQ,OACNvL,KAAK+E,SAAS,CAACiF,uBAAuB,I,UAGhC,IAAIhL,SAAQ,SAAAC,GAAO,OAAIuM,WAAWvM,EAAS,Q,QACjDe,KAAKyL,gBACCC,EAAS1L,KAAK2H,UAAUe,QACxBiD,EAAe3L,KAAK4H,gBAAgBc,QAC1C3L,QAAQ6O,IAAIF,EAAQC,EAAcD,EAAO7K,MAAO6K,EAAO5K,QACvD6K,EAAa9K,MAAQ6K,EAAO7K,MAC5B8K,EAAa7K,OAAS4K,EAAO5K,OACjB6K,EAAavC,WAAW,MAChCC,UAAUqC,EAAQ,EAAG,G,gMASGG,G,sFACO,IAA/B7L,KAAK2E,MAAMyF,gB,wDAEfpK,KAAK+E,SAAS,CAACqF,gBAAiB,iB,SACNrH,I,OAE1B,IAFA/C,KAAKqD,a,OACLrD,KAAK8L,yBAA2B,IAAIlM,MAAMmM,OAAOlM,KAAKG,KAAKqD,cAAchK,QACzE,MAAkB0S,OAAOlM,KAAKG,KAAKqD,cAAnC,eAAWhF,EAAX,KACI2B,KAAK8L,yBAAyB9L,KAAKqD,aAAahF,IAAQA,EAG5D8D,EADkB0J,EAAW,uBAAyB,uBAC7B,SAACG,GACtB,EAAKC,WAAa,IAAIrS,YAAYoS,GAElCjP,QAAQ6O,IAAI,sBAAuB,EAAKK,WAAW5S,QAHrB,oBAKd,EAAK4S,YALS,IAK9B,gCAAWC,EAAX,QACQA,EAAI,QACJvN,MAAM,0CAA4CuN,IAP5B,8BAQ9B9P,EAAgB,EAAK6P,YACrB,EAAKlH,SAAS,CAACqF,iBAAiB,EAAM5B,aAAc,IAAKe,KAAM,kB,sJAKnE,GAAKvJ,KAAK2E,MAAMqF,sBAEhB,IAAqC,IAAjChK,KAAK2E,MAAMsF,mBAAgCjK,KAAKmM,kBAMpD,GAFAnM,KAAK+E,SAAS,CAACkF,mBAAoBjK,KAAK2E,MAAMsF,oBAE0B,OAApEjK,KAAKqI,qBAAqBrI,KAAKqI,qBAAqBhP,OAAS,GAAa,CAC1E,IAAM+S,EAAiBpM,KAAKqI,qBAAqBrI,KAAKqI,qBAAqBhP,OAAS,GACpF2G,KAAK+E,SAASqH,GACdpM,KAAKuI,cAAc6D,EAAexH,KAAMwH,EAAe5D,cACvDxI,KAAKqI,qBAAqBrI,KAAKqI,qBAAqBhP,OAAS,GAAK,WATlEsF,MAAM,oC,4KAcLqB,KAAK2E,MAAMqF,sB,iDAEhBhK,KAAKyL,gBACDY,EAAiB,KACjBC,EAAe,GACV7I,EAAI,E,YAAGA,EAAI,I,iCACYzD,KAAKuM,kBAC7BF,GAAkB,EAAIC,GACtBD,GAAkB,EAAI,EAAIC,GACpB,IAAN7I,EAAU,GAAY,IAANA,EAAU,GAAK,G,OAHnCzD,KAAKwM,e,OAKLH,EAAiBrM,KAAKwM,eAAeC,MACrCH,GAAgB,E,QAPI7I,I,8BASxB1G,QAAQ6O,IAAI,mBAAoB5L,KAAKwM,gBAErCxM,KAAKiI,YAAYyE,OAAOL,GACxBrM,KAAK2M,wBAAwBN,GAC7BrM,KAAK4M,sBACL7P,QAAQ6O,IAAI,oBAAqB5L,KAAKwM,gB,UAChC,IAAIxN,SAAQ,SAAAC,GAAO,OAAIuM,WAAWvM,EAAS,Q,QACjDe,KAAK+E,SAAS,CAACkF,mBAAmB,I,wLAUdlD,EAAKD,EAAK+F,G,6EAC1BC,EAAa,CAACC,OAAQ,GACjBtJ,EAAI,E,YAAGA,EAAIoJ,G,wBACVG,EAAYjG,EAAMtD,GAAKqD,EAAMC,IAAQ8F,EAAc,IACnDI,EAASjN,KAAK2M,wBAAwBK,IACjCD,MAAQD,EAAWC,QAC1BD,EAAaG,G,SACX,IAAIjO,SAAQ,SAAAC,GAAO,OAAIuM,WAAWvM,EAAS,O,OALpBwE,I,8BAOjC1G,QAAQ6O,IAAI,oBAAqB7E,EAAK,KAAMD,EAAK,OAAQgG,G,kBAClDA,G,wJAIP,IAAM3D,EAAMlL,OAAOiP,GAAGC,OAAO,gBAEvBC,EAAanP,OAAOiP,GAAGC,OAAO,4BAC9BE,EAAsBjJ,KAAKC,MAAM+I,EAAWE,OAAOzM,MAAQb,KAAKwM,eAAeC,OAC/Ec,EAAuBnJ,KAAKC,MAAM+I,EAAWE,OAAOxM,OAASd,KAAKwM,eAAeC,OACnFe,EAAQ,IAAIvP,OAAOiP,GAAGO,IACtBC,EAAQ,IAAIzP,OAAOiP,GAAGS,KAAKN,EAAqBE,GACpDtP,OAAOiP,GAAGU,OAAOR,EAAYI,EAAOE,EAAO,EAAG,EAAGzP,OAAOiP,GAAGW,YAE3D,IAAMC,EAAM,IAAI7P,OAAOiP,GAAGO,IACpBM,EAAO,IAAI9P,OAAOiP,GAAGO,IACrBO,EAAY/P,OAAOiP,GAAGe,iBAC5BhQ,OAAOiP,GAAGgB,cAAc/E,EAAKqE,EAAOM,EAAKE,EAAWD,GACpD,IACII,EADSlQ,OAAOiP,GAAGkB,UAAUN,EAAKC,GAChBM,OAClB7M,EAAQ,IAAIvD,OAAOiP,GAAGoB,OAAO,IAAK,EAAG,EAAG,KACxCC,EAAQ,IAAItQ,OAAOiP,GAAGsB,MAAML,EAAShO,EAAIqN,EAAMiB,KAAMN,EAAS/N,EAAIoN,EAAMkB,MAC5EzQ,OAAOiP,GAAGyB,UAAUxF,EAAKgF,EAAUI,EAAO/M,EAAO,EAAGvD,OAAOiP,GAAG0B,OAAQ,GACtE3Q,OAAOiP,GAAG2B,OAAO,qBAAsB1F,GACvCA,EAAIuD,SAAUU,EAAWV,SAAUc,EAAMd,SAAUoB,EAAIpB,SAAUqB,EAAKrB,SACtE1M,KAAKwM,eAAesC,mBAAqB,CACrC3O,EAAGgO,EAAShO,EAAGC,EAAG+N,EAAS/N,K,gCAIzBD,EAAGC,GACT,IACI2O,GAD0B/O,KAAKwM,eAAesC,mBAAmB1O,EAAIJ,KAAKwM,eAAewC,gBAAgB5O,IAC5D,IAAMJ,KAAKwM,eAAeC,OAW3E,OAVIsC,EAAoB,KAAQA,EAAoB,QAChDA,EAAoB,GASjB,CACH5O,EAAGH,KAAKwM,eAAewC,gBAAgB7O,EAAIH,KAAKwM,eAAeC,OAAS,MAAQ,KAAOtM,GACvFC,EAAGJ,KAAKwM,eAAewC,gBAAgB5O,EAAIJ,KAAKwM,eAAeC,MAAQsC,GAAqB,IAAM,KAAO3O,M,0CAI7FA,GAChB,IACI2O,GAD0B/O,KAAKwM,eAAesC,mBAAmB1O,EAAIJ,KAAKwM,eAAewC,gBAAgB5O,IAC5D,IAAMJ,KAAKwM,eAAeC,OAO3E,OANIsC,EAAoB,KAAQA,EAAoB,QAChDA,EAAoB,GAKjB,CACH5O,EAAGH,KAAKwM,eAAewC,gBAAgB7O,EAAgC,IAA5BH,KAAKwM,eAAeC,MAC/DrM,EAAGJ,KAAKwM,eAAewC,gBAAgB5O,EAAIJ,KAAKwM,eAAeC,MAAQsC,GAAqB,IAAM,IAAM3O,M,qCAK5G,IACI2O,GAD0B/O,KAAKwM,eAAesC,mBAAmB1O,EAAIJ,KAAKwM,eAAewC,gBAAgB5O,IAC5D,IAAMJ,KAAKwM,eAAeC,OAG3E,OAFIsC,EAAoB,KAAQA,EAAoB,QAChDA,EAAoB,GACjB,IAAI9Q,OAAOiP,GAAG+B,KACjB7K,KAAKC,MAAMrE,KAAKwM,eAAewC,gBAAgB7O,GAAIiE,KAAKC,MAAMrE,KAAKwM,eAAewC,gBAAgB5O,GAClGgE,KAAKC,MAAkC,KAA5BrE,KAAKwM,eAAeC,OAC/BrI,KAAKC,MAAMrE,KAAKwM,eAAeC,MAAQsC,EAAoB,Q,8CAI3CtC,GACpB,GAAIzM,KAAKiI,YAAYiH,IAAIzC,GACrB,OAAOzM,KAAKiI,YAAYnL,IAAI2P,GAEhC,IAAMtD,EAAMlL,OAAOiP,GAAGC,OAAO,gBACvBC,EAAanP,OAAOiP,GAAGC,OAAO,yBAE9BE,EAAsBjJ,KAAKC,MAAM+I,EAAWE,OAAOzM,MAAQ4L,GAC3Dc,EAAuBnJ,KAAKC,MAAM+I,EAAWE,OAAOxM,OAAS2L,GAC/De,EAAQ,IAAIvP,OAAOiP,GAAGO,IACtBC,EAAQ,IAAIzP,OAAOiP,GAAGS,KAAKN,EAAqBE,GACpDtP,OAAOiP,GAAGU,OAAOR,EAAYI,EAAOE,EAAO,EAAG,EAAGzP,OAAOiP,GAAGW,YAE3D,IAAMC,EAAM,IAAI7P,OAAOiP,GAAGO,IACpBM,EAAO,IAAI9P,OAAOiP,GAAGO,IAErBO,EAAY/P,OAAOiP,GAAGe,iBAC5BhQ,OAAOiP,GAAGgB,cAAc/E,EAAKqE,EAAOM,EAAKE,EAAWD,GACpD,IAAI1O,EAASpB,OAAOiP,GAAGkB,UAAUN,EAAKC,GAClCI,EAAW9O,EAAOgP,OAClB7M,EAAQ,IAAIvD,OAAOiP,GAAGoB,OAAO,IAAK,EAAG,EAAG,KACxCC,EAAQ,IAAItQ,OAAOiP,GAAGsB,MAAML,EAAShO,EAAIqN,EAAMiB,KAAMN,EAAS/N,EAAIoN,EAAMkB,MAC5EzQ,OAAOiP,GAAGyB,UAAUxF,EAAKgF,EAAUI,EAAO/M,EAAO,EAAGvD,OAAOiP,GAAG0B,OAAQ,GACtE3Q,OAAOiP,GAAG2B,OAAO,qBAAsB1F,GACvCA,EAAIuD,SAAUU,EAAWV,SAAUc,EAAMd,SAAUoB,EAAIpB,SAAUqB,EAAKrB,SAEtE,IAAIK,EAAQ1N,EAAO8P,OAEnB,OADAnP,KAAKiI,YAAYxO,IAAIgT,EAAOM,GACrB,CACHA,QAAON,QACPuC,gBAAiB,CAAC7O,EAAGgO,EAAShO,EAAGC,EAAG+N,EAAS/N,M,uCAKjD,OAAOJ,KAAK2E,MAAMqF,4BACU7N,IAAxB6D,KAAKwM,gBACLxM,KAAKwM,eAAe4C,eAAe,wB,kNA6I9BC,G,oEAAAA,G,SAAmBC,EAAGC,GAC3B,GAAU,OAAND,GAAoB,OAANC,EACd,OAAO,EAEX,IADA,IAAIC,EAAWF,EAAE9G,eAAkB+G,EAAE/G,aAC5BpI,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACfmP,EAAE1K,KAAK,CAACzE,EAAGC,MAAQmP,EAAE3K,KAAK,CAACzE,EAAGC,MAC9BoP,GAAW,GACvB,OAAOA,GAjJNxP,KAAKmM,iB,iDA+BV,IA5BMC,EAAiB,CACnBxH,KAAM,GACN4D,aAAc,GAGlBxI,KAAKyL,gBACCgE,EAAK9I,YAAYD,MAEjByC,EAAMlL,OAAOiP,GAAGC,OAAO,gBACvBuC,EAAQ,IAAIzR,OAAOiP,GAAGS,KAAK,EAAG,GACpC1P,OAAOiP,GAAGyC,aAAaxG,EAAKA,EAAKuG,EAAO,EAAG,EAAGzR,OAAOiP,GAAG0C,gBAClDC,EAAW,CAAC1G,GAEZ2G,EAAgB,SAAC3P,EAAGC,GACtB,IAAM2P,EAAW5G,EAAI6G,SAAS5L,KAAKC,MAAMjE,GAAIgE,KAAKC,MAAMlE,IAClD8P,EAAa,CAACC,EAAGH,EAAS,GAAII,EAAGJ,EAAS,GAAIK,EAAGL,EAAS,IAC1DM,EAASjM,KAAKkM,KAAKL,EAAWC,EAAID,EAAWC,EAAID,EAAWE,EAAIF,EAAWE,EAAIF,EAAWG,EAAIH,EAAWG,GAC/G,OAAO,eAAIH,EAAX,CAAuBI,YAIvBE,EAAsB,IAAItS,OAAOiP,GAAGoB,OAAO,GAAK,GAAK,GAAK,KAC1DkC,EAAsB,IAAIvS,OAAOiP,GAAGoB,OAAO,IAAK,EAAK,IAAK,KAC1DmC,EAAsB,IAAIxS,OAAOiP,GAAGoB,OAAO,IAAK,IAAK,EAAK,KAC1DoC,EAAsB,IAAIzS,OAAOiP,GAAGoB,OAAO,IAAK,IAAK,IAAK,KAC1DqC,EAAsB,IAAI1S,OAAOiP,GAAGoB,OAAO,GAAK,IAAK,IAAK,KAC1DsC,EAA2B,KAC3BC,GAAmB,EACdzQ,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAASD,EAAI,EAAGA,EAAI,EAAGA,IACb2Q,EAAS9Q,KAAK+Q,UAAU5Q,EAAGC,IAC3B4Q,EAAUlB,EAAcgB,EAAO3Q,EAAG2Q,EAAO1Q,EAAI,KACvCiQ,OAASQ,IACjBA,EAAkBG,EAAQX,OAC1BO,EAA2B,CAACzQ,IAAGC,MAI3C,IAASA,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAASD,EAAI,EAAGA,EAAI,EAAGA,IACb2Q,EAAS9Q,KAAK+Q,UAAU5Q,EAAGC,GAC3B6Q,EAAUH,EAAO3Q,EACjB+Q,EAAUJ,EAAO1Q,EAGb,EAEJ+Q,EAAarB,EAAcmB,EAAgBC,GAC3CE,EAAatB,EAAcmB,EAHvB,EAGuCC,EAHvC,GAIJG,EAAavB,EAAcmB,EAJvB,EAIuCC,EAJvC,GAKJI,EAAaxB,EAAcmB,EALvB,EAKuCC,EALvC,GAMJK,EAAazB,EAAcmB,EANvB,EAMuCC,EANvC,GAOJM,EAAuBrR,IAAMyQ,EAAyBzQ,GAAKC,IAAMwQ,EAAyBxQ,EAE1FqR,EAAkBD,GAAyBrR,IAAMyQ,EAAyBzQ,EAAI,GAAKC,IAAMwQ,EAAyBxQ,EAClHsR,EAAkBF,GAAyBrR,IAAMyQ,EAAyBzQ,EAAI,GAAKC,IAAMwQ,EAAyBxQ,EAClHuR,EAAkBH,GAAyBrR,IAAMyQ,EAAyBzQ,GAAKC,IAAMwQ,EAAyBxQ,EAAI,EAClHwR,EAAkBJ,GAAyBrR,IAAMyQ,EAAyBzQ,GAAKC,IAAMwQ,EAAyBxQ,EAAI,EAClHyR,EAAeF,GAAkBF,EACjCK,EAAeH,GAAkBD,EACjCK,EAAeH,GAAkBH,EACjCO,EAAeJ,GAAkBF,EAEnClQ,EAAQ+O,EAER0B,EAAYT,EAAuB,IAAM,IACvCU,GACDf,EAAOd,QAAa4B,IACpBb,EAAOf,SAAcwB,EAAe,IAAM,OAC1CR,EAAQhB,SAAayB,EAAe,IAAM,OAC1CR,EAASjB,SAAY0B,EAAe,IAAM,OAC1CR,EAAUlB,SAAW0B,EAAe,IAAM,MAEzCI,EAAgBX,EAAuB,EAAI,KAC3CY,GACDjB,EAAOhB,GAAQgB,EAAOf,EAAO+B,IAC7Bf,EAAOjB,GAAQiB,EAAOhB,GAAQyB,EAAeM,EAAgB,QAC7Dd,EAAQlB,GAAOkB,EAAQjB,GAAO0B,EAAeK,EAAgB,QAC7Db,EAASnB,GAAMmB,EAASlB,GAAM2B,EAAeI,EAAgB,QAC7DZ,EAAUpB,GAAKoB,EAAUnB,GAAK4B,EAAeG,EAAgB,OAIlE/F,EAAexH,KAAK,CAACzE,EAAGC,IAAM,MAEzB8R,GAAgB,GAAKE,GAAwB,GAAOF,GAAgB,GAAKE,GAAwB,KAE5FC,EAAWjO,KAAK0C,IAAIqK,EAAOjB,EAAGkB,EAAOlB,EAAGmB,EAAQnB,EAAGoB,EAASpB,EAAGqB,EAAUrB,GACzEoC,EAAWlO,KAAK0C,IAAIqK,EAAOhB,EAAGiB,EAAOjB,EAAGkB,EAAQlB,EAAGmB,EAASnB,EAAGoB,EAAUpB,GAC3EkC,EAAoB,KAAXC,GACT9Q,EAAQgP,EACRpE,EAAexH,KAAK,CAACzE,EAAGC,IAAM,QAE9BoB,EAAQiP,EACRrE,EAAexH,KAAK,CAACzE,EAAGC,IAAM,SAGlCnC,OAAOgE,YAEHuP,GACAzU,QAAQ6O,IAAI,eAChB7O,QAAQ6O,IAAI,UAAWzL,EAAGC,EAAGoR,EAAsBY,EAAsBjB,EAAQC,EAAQC,EAASC,EAAUC,IAE5GgB,EAAK,IAAItU,OAAOiP,GAAGsB,MAAMyC,EAAU,EAAGC,EAAU,GAChDsB,EAAK,IAAIvU,OAAOiP,GAAGsB,MAAMyC,EAAU,EAAGC,EAAU,GACpDjT,OAAOiP,GAAGyB,UAAUxF,EAAKoJ,EAAIC,EAAIhR,EAAO,EAAGvD,OAAOiP,GAAG0B,OAAQ,GAGrE,IAAS6D,EAAa,EAAGA,EAAa,EAAGA,IAC/B3B,EAAS9Q,KAAK0S,oBAAoBD,GAClCxB,EAAUH,EAAO3Q,EACjB+Q,EAAUJ,EAAO1Q,EACjB2P,EAAW5G,EAAI6G,SAAS5L,KAAKC,MAAM6M,GAAU9M,KAAKC,MAAM4M,IACxDhB,EAAa,CAACC,EAAGH,EAAS,GAAII,EAAGJ,EAAS,GAAIK,EAAGL,EAAS,IAC5DwC,GAAK,IAAItU,OAAOiP,GAAGsB,MAAMyC,EAAU,GAAIC,EAAU,IACjDsB,GAAK,IAAIvU,OAAOiP,GAAGsB,MAAMyC,EAAU,GAAIC,EAAU,IACjD1P,GAAQmP,EACRV,EAAWC,EAAmB,KAAfD,EAAWG,IAC1B5O,GAAQkP,EACRtE,EAAe5D,aAAepE,KAAK0C,IAAIsF,EAAe5D,aAAciK,EAAa,IAGrFxU,OAAOiP,GAAGyB,UAAUxF,EAAKoJ,GAAIC,GAAIhR,GAAO,EAAGvD,OAAOiP,GAAG0B,OAAQ,GAMjE,IAJM+D,GAAY3S,KAAK4S,eACjBC,GAAU1J,EAAI2J,IAAIH,IACxB9C,EAAS1M,KAAK0P,IACd5U,OAAOiP,GAAG2B,OAAO,qBAAsBgE,IACvC,QAAkBhD,EAAlB,yBACQnD,S,GACFqG,GAAKpM,YAAYD,MACvB3J,QAAQ6O,IAAI,aAAemH,GAAKtD,GAAM,MACtCzP,KAAK+E,SAAS,CAACoF,WAAY4I,GAAKtD,IAe1BJ,GAAmBrP,KAAKqI,qBAAqB,GAAIrI,KAAKqI,qBAAqB,MAC7EgH,GAAmBrP,KAAKqI,qBAAqB,GAAIrI,KAAKqI,qBAAqB,MAC3EgH,GAAmBrP,KAAKqI,qBAAqB,GAAI+D,G,wBAEjDpM,KAAK+E,SAASqH,G,UACRpM,KAAKuI,cAAc6D,EAAexH,KAAMwH,EAAe5D,c,eAEjExI,KAAKqI,qBAAqB2K,QAC1BhT,KAAKqI,qBAAqBlF,KAAKiJ,G,kBAExBA,G,6IAIP,IAAMrB,EAAQ/K,KAAKyH,SAASiB,QACtBgD,EAAS1L,KAAK2H,UAAUe,QAGxBuK,EAAUvH,EAAOtC,WAAW,MAI5BtI,EAASsD,KAAKC,MAAe0G,EAAMmI,YAAcnI,EAAMoI,WAD/C,KAEdpW,QAAQ6O,IAAI,+BAAiCb,EAAMoI,WAAa,IAAMpI,EAAMmI,YAAhE,uBAAiHpS,GAC7H4K,EAAO7K,MAHO,IAId6K,EAAO5K,OAASA,EAChBmS,EAAQ5J,UAAU0B,EAAO,EAAG,EALd,IAKwBjK,K,wDAGnBsS,EAAgBC,EAAYC,G,sFACjB,IAA1BF,EAAe/Z,O,gBACf,O,SAAM,G,wCAIJka,EAAcH,EAAe,GAC7BnH,EAAajM,KAAKiM,WAClBuH,EAAWpP,KAAK2C,IAAIkF,EAAW5S,OAAQga,EAAaC,GACjD7P,EAAI4P,E,YAAY5P,EAAI+P,G,oBACrBvH,EAAWxI,KAAO8P,E,+BACMvT,KAAKyT,sBAAsBL,EAAe3X,MAAM,GAAIgI,EAAG,O,2DAC3E,OADOiQ,E,kBACP,CAAOjQ,GAAP,mBAAaiQ,I,iJAHcjQ,I,kIAMd,IAAD,IACSzD,KAAK2T,2BADd,mBACjBP,EADiB,KAElBQ,GAFkB,UAER,IAFQ,cAGJ5T,KAAKyT,sBAAsBL,EAAgB,EAAG,MAH1C,IAGxB,gCAAWS,EAAX,QACID,EAAQzQ,KAAK0Q,IAJO,8BAKxB7T,KAAK+E,SAAS,CAACyF,iBAAkBoJ,M,iDAGT,IAAD,SAEjBE,EAAoB9T,KAAK8H,uBAC1B7D,KAAI,SAAC8P,GAAD,OAAS,EAAK1Q,aAAa0Q,EAAIrL,QAAQlD,sBAC1C4N,EAAiB,GAJA,cAKNU,GALM,IAKvB,2BAAoC,CAAC,IAA1BE,EAAyB,QAChC,QAAW7X,IAAP6X,EACA,MACJZ,EAAejQ,KAAK6Q,IARD,8BAiBvB,IAHA,IAAMC,EAA8B,GAC9BC,EAAgC,GAClCC,GAAQ,EACZ,gBAAwBf,EAAxB,CAAwC,OAAxC,eAA+C,CAA1C,IAAMpP,EAAK,KACZ,QAAc7H,IAAV6H,EACA,MACAmQ,GACAF,EAA4B9Q,KAAK,IAASgE,OAAOnH,KAAK2E,MAAM8F,2BAC5DyJ,EAA8B/Q,KAAK,IAASgE,OAAOnH,KAAK2E,MAAM+F,kCAGhD,OAAV1G,GAAmD,OAAjChE,KAAK2E,MAAM4F,mBAE7B0J,EAA4B9Q,KAAKiB,KAAK0C,IAAI,EAAG9G,KAAK2E,MAAM4F,oBACxD2J,EAA8B/Q,KAAK,IAASgE,OAAOnH,KAAK2E,MAAMkG,mCAE9DoJ,EAA4B9Q,KAAK,IAASgE,OAAOnH,KAAK2E,MAAMgG,0BAC5DuJ,EAA8B/Q,KAAK,IAASgE,OAAOnH,KAAK2E,MAAMiG,iCAGtEuJ,GAAQ,EAEZ,MAAO,CACHva,YAAYmK,KAAKqP,GACjBxZ,YAAYmK,KAAKkQ,GACjBla,aAAagK,KAAKmQ,M,wCAIRtP,EAAM4D,GAGpB,IAFA,IAAMhO,EAAO,GACPC,EAAS,GACN2F,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,IAAMiU,EAAYxP,EAAK,CAACzE,EAAGC,IACT,QAAdgU,GACA5Z,EAAK2I,KAAK,EAAI/C,EAAID,GACJ,SAAdiU,GACA3Z,EAAO0I,KAAK,EAAI/C,EAAID,GAIhC,IADA,IAAIkU,GAAuB,EAC3B,MAAgB,CAAC,IAAK,IAAK,IAAK,KAAhC,gBAAK,IAAM1U,EAAC,KACJ6I,IAAiB7I,GAAK6I,IAAiBrB,OAAOxH,KAC9C0U,EAAsBlN,OAAOxH,IACrC,MAAO,CAACnF,OAAMC,SAAQ4Z,yB,6EAGNzP,EAAM4D,G,4GACtBzL,QAAQ6O,IAAI,qBAAsBpD,EAAc5D,GAC1C6K,EAAK9I,YAAYD,M,EACqB1G,KAAKsU,kBAAkB1P,EAAM4D,GAAlEhO,E,EAAAA,KAAMC,E,EAAAA,OAAQ4Z,E,EAAAA,oB,SAEfvb,E,OAuBN,GArBIkH,KAAK2E,MAAMyF,iBACLmK,EAAuBvU,KAAK2T,2BAClC5W,QAAQ6O,IAAI,wBAAyB2I,GAErCC,EAAgB7Y,EAAyC,WAAzC,GACZnC,WAAWuK,KAAKvJ,GAChBhB,WAAWuK,KAAKtJ,GAChB4Z,GAHY,mBAITE,MAGPC,EAAgBja,EACZf,WAAWuK,KAAKvJ,GAChBhB,WAAWuK,KAAKtJ,GAChB4Z,EAEAza,YAAYmK,KAAK,IACjBhK,aAAagK,KAAK,UAIJ5H,IAAlBqY,EAA6B,CAU7B,IATIC,EAAO,EACPC,EAAO,EACPC,GAAe,EACfrL,EAAQ,GAMHlJ,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAASD,EAAI,EAAGA,EAAI,EAAGA,IACnBmJ,EAAM,CAACnJ,EAAGC,IAAMoU,EAAc,EAAIpU,EAAID,GACd,EAClByU,EADkB,EACKJ,EAAc,EAAIpU,EAAID,GAC9B,OAAjByE,EAAK,CAACzE,EAAGC,KAAgBwU,EAAuBD,IAChDA,EAAcC,EACdF,EAAOvU,EACPsU,EAAOrU,GAIb2J,EAAkByK,EAAc,IACtCxU,KAAK+E,SAAS,CAAEuE,QAAOpJ,KAAMyU,GAAe,EAAI,CAACD,EAAMD,GAAQ,KAAMzT,OAAO,EAAM+I,yBAElF/J,KAAK+E,SAAS,CAAE/D,OAAO,IAErB+R,EAAKpM,YAAYD,MACvB1G,KAAK+E,SAAS,CAACmF,oBAAqB6I,EAAKtD,I,kJAIzCzP,KAAK+E,SAAS,CAAC+E,WAAW,GAAD,mBAClB9J,KAAK2E,MAAMmF,YADO,CAErB,CAAClF,KAAM5E,KAAK2E,MAAMC,KAAM4D,aAAcxI,KAAK2E,MAAM6D,oB,8BAIjDrI,EAAGC,EAAGyU,GACV,IAAMjQ,EAAI,eAAQ5E,KAAK2E,MAAMC,MACzBwP,EAAYxP,EAAK,CAACzE,EAAGC,IACrBoI,EAAexI,KAAK2E,MAAM6D,aAG9B,GAFAxI,KAAK8U,mBAEmB,eAApB9U,KAAK2E,MAAM4E,KAAuB,CAClC,OAAQ6K,GACJ,KAAK,KACDA,EAAYS,EAAW,MAAQ,OAC/B,MACJ,IAAK,OACDT,EAAY,MACZ,MACJ,IAAK,MACDA,EAAY,KAGpBxP,EAAK,CAACzE,EAAGC,IAAMgU,MACZ,CAEH,GAAkB,OAAdA,EACA,OAUAA,EATkB,SAACW,GAAS,IAAD,gBACRA,GADQ,IAC3B,gCAAWvQ,EAAX,QACI,GAAIA,EAAK,KAAOrE,GAAKqE,EAAK,KAAOpE,EAC7B,OAAO,GAHY,8BAI3B,OAAO,EAEP4U,CAAc,GAAD,mBAAKhV,KAAK2E,MAAM6E,YAAY7F,QAA5B,YAAuC3D,KAAK2E,MAAM6E,YAAY5F,QAA9D,YAAyE5D,KAAK2E,MAAM6E,YAAY3F,UACjG,MAEA,OAEhBe,EAAK,CAACzE,EAAGC,IAAMgU,EAEf5L,EAAe,EACf,cAAgB,CAAC,IAAK,IAAK,KAA3B,eAAiC,CAA5B,IAA4B,EAAtB7I,EAAC,KACFsV,EAAQjV,KAAK2E,MAAM6E,YAAY,QAAU7J,GAC3CuV,GAAS,EAFgB,cAGVD,GAHU,IAG7B,4BACuB,QAAfrQ,EADR,WAEQsQ,GAAS,IALY,8BAM7B1M,GAAgB0M,EAEpBlV,KAAK+E,SAAS,CAAEyD,iBAEpBxI,KAAK+E,SAAS,CAAEH,SAChB5E,KAAKuI,cAAc3D,EAAM4D,K,mCAMzB,IAFA,IAAM2M,EAAgBnV,KAAKgI,iBACrBoN,EAAW,GACjB,MAAmB,CAAC,cAAe,OAAQ,gBAA3C,gBAAK,IAAMxM,EAAI,KACXwM,EAASxM,GAAQuM,EAAcvM,GAE/B5I,KAAK2E,MAAMyF,kBACXgL,EAAS5M,aAAe,KAC5BxI,KAAK+E,SAASqQ,GACdpV,KAAKuI,cAAc6M,EAASxQ,KAAMwQ,EAAS5M,gB,wCAI3C,IAAMsB,EAAU,YAAO9J,KAAK2E,MAAMmF,YAClC,GAA0B,IAAtBA,EAAWzQ,OAAf,CAEA,IAAMgc,EAAYvL,EAAWwL,MAC7BtV,KAAK+E,SAAS,CAACH,KAAMyQ,EAAUzQ,KAAM4D,aAAc6M,EAAU7M,aAAcsB,eAC3E9J,KAAKuI,cAAc8M,EAAUzQ,KAAMyQ,EAAU7M,iB,mCAIrB,OAApBxI,KAAK2E,MAAMzE,MAAsD,OAArCF,KAAK2E,MAAMC,KAAK5E,KAAK2E,MAAMzE,OACvDF,KAAK2B,QAAL,MAAA3B,KAAA,YAAgBA,KAAK2E,MAAMzE,S,kCAI/B,GAAwB,OAApBF,KAAK2E,MAAMzE,MAAsD,OAArCF,KAAK2E,MAAMC,KAAK5E,KAAK2E,MAAMzE,MAC3D,CACIF,KAAK2B,QAAL,MAAA3B,KAAA,YAAgBA,KAAK2E,MAAMzE,MAA3B,SAAiC,KADrC,MAEgDF,KAAKsU,kBAAkBtU,KAAK2E,MAAMC,KAAM5E,KAAK2E,MAAM6D,cAAxFhO,EAFX,EAEWA,KAFX,EAEiBC,OAFjB,EAEyB4Z,oBACD,IAAhB7Z,EAAKnB,QACL2G,KAAKuV,oB,mCAMb,IAAMC,EAAaxV,KAAK+H,SAASW,QACjC,GAAmB,OAAf8M,EAAJ,CAEA,IAAMjL,EAAoBiL,EAAW7Q,MAAM8B,YAAc,KAAO+O,EAAWlO,0BAA0BkO,EAAWnO,qBAChHrH,KAAK+E,SAAS,CAACwF,sBACfxN,QAAQ6O,IAAI,uBAAwBrB,GACpCiL,EAAWzQ,SAAS,CAChBqB,6BAA8B,EAC9BC,aAAcM,YAAYD,MAE1BH,wBAAwB,EACxBC,sBAAuB,EACvBF,cAAc,EACdG,aAAa,IAEjBzG,KAAKuI,cAAcvI,KAAK2E,MAAMC,KAAM5E,KAAK2E,MAAM6D,iB,8JAI3CiN,EAA2C,YAA5BzV,KAAK2E,MAAM6D,aAA6B,EAAIrB,OAAOnH,KAAK2E,MAAM6D,cAC7E5D,EAAO5E,KAAK2E,MAAMC,KAED,MADrB6Q,E,wBAGUlB,EAAuBvU,KAAK2T,2BAClC3T,KAAK0V,a,SACiB1V,KAAK2V,cAAcpB,G,eAErCkB,EAAe,EACf7Q,EAAO5E,KAAK6E,iBAEZ4Q,EAAe,E,QAGvBzV,KAAK8U,mBACL9U,KAAK+E,SAAS,CAACH,OAAM4D,aAAc,GAAKiN,IACxCzV,KAAKuI,cAAc3D,EAAM,GAAK6Q,G,oLAGdlB,G,0FACDvU,KAAKsU,kBAAkBtU,KAAK2E,MAAMC,KAAM5E,KAAK2E,MAAM6D,cAA3DhO,E,EAAAA,UACsB2B,IAAzBoY,IACAA,EAAuBvU,KAAK2T,4B,SAC1B7a,E,eAKaqD,KAJbyZ,EAAa1Z,EAAwB,WAAxB,GACf1C,WAAWuK,KAAKvJ,IADD,mBAEZ+Z,M,0CAKI,G,cAEXxX,QAAQ6O,IAAI,eAAgBgK,GACtBrQ,EAAevF,KAAK8L,yBAAyB8J,GAC7CxC,EAAiBmB,EAAqB,IACxCsB,EAAYzC,EAAe/Z,UAEb2G,KAAK8H,uBAAuBzO,SAC1C2G,KAAK8V,eACLD,KAEJ7V,KAAK8H,uBAAuB+N,GAAWnN,QAAQqN,yBAAyBxQ,G,mBACjE,G,6IAKP,IADA,IAAMyQ,EAAgBhW,KAAK8H,uBAAuB7D,KAAI,SAAC8P,GAAD,OAASA,EAAIrL,WAC1DjF,EAAI,EAAGA,EAAIuS,EAAc3c,OAAQ,EAAGoK,IACzCuS,EAAcvS,GAAGsB,SAASiR,EAAcvS,EAAI,GAAGkB,OAEnDqR,EAAcA,EAAc3c,OAAS,GAAG4c,e,sCAG5BC,GAAc,IAAD,OACzB,OAAO,yBAAK1V,MAAO,CAAC2V,YAAa,WAC5BzW,EAAa,GAAGuE,KACb,SAAC7D,GAAD,OAAO,yBAAK/B,IAAK+B,EAAGI,MAAO,CACvBC,QAAS,SAERf,EAAa,GAAGuE,KACb,SAAC9D,GAAD,OAAO,kBAAC,EAAD,CACH9B,IAAK8B,EAAI,IAAMC,EACfD,EAAGA,EAAGC,EAAGA,EACTuB,QAAS,kBAAM,EAAKA,QAAQxB,EAAGC,IAC/BE,KAAM,EAAKqE,MAAMC,KAAK,CAACzE,EAAGC,IAC1BG,KAAM,EAAKoE,MAAM2E,MAAM,CAACnJ,EAAGC,IAC3BY,MAAO,EAAK2D,MAAM3D,MAClBd,KAAM,EAAKyE,MAAMzE,KACjB2B,UAAWqU,EAAc,EAAI,EAC7BxU,QAASwU,EAAc,GAAM,GAAM,EAAKvR,MAAM2E,MAAM,CAACnJ,EAAGC,SAAMjE,c,yCASlF,GAAK6D,KAAK2E,MAAMsF,kBAEhB,OAAO,yBAAKzJ,MAAO,CACf4V,SAAU,WACVC,IAAK,QACLC,KAAM,QACNC,UAAW,oBACXrV,OAAQ,GACRT,QAAS,iBAGRT,KAAKwW,iBAAgB,M,+BAO1B,IAHM,IAAD,OACDC,EAAY,EACZC,GAAmB,EACdtW,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,EAAI,EAAGA,EAAI,EAAGA,IACa,OAA5BH,KAAK2E,MAAMC,KAAK,CAACzE,EAAGC,MACpBqW,IACgC,QAA5BzW,KAAK2E,MAAMC,KAAK,CAACzE,EAAGC,MACpBsW,GAAmB,IAInC,OAAO,yBAAKlW,MAAO,CACfoF,OAAQ,OACRpE,MAAO,UAEP,yBAAKmV,UAAU,aACX,yBAAKnW,MAAO,CAAC2V,YAAa,MAAOS,UAAW,UACxC,yBAAKD,UAAU,iBAAiBnW,MAAO,CAACqW,oBAAqB,mBACzD,8BAAM,iDACN,8BAAM,kDACN,qDACA,qCAAaJ,EAAb,QACHzW,KAAK2E,MAAMyF,iBAAmBpK,KAAK2E,MAAM0F,mBAC1C,oCACI,kBAAC,GAAD,CAAY0J,IAAK/T,KAAK+H,SAAUX,kBAAmBpH,KAAK2E,MAAMyC,oBAC9D,qDACA,qCAA8C,OAAjCpH,KAAK2E,MAAM4F,kBAA6B,IAAMvK,KAAK2E,MAAM4F,kBAAtE,SAGHvK,KAAK2E,MAAMyF,iBAAmBpK,KAAK2E,MAAM0F,mBAAqBrK,KAAK2E,MAAM2F,kBAC1E,oCACI,8BAAM,oDAA2C,8BAAM,qDACvD,sDAAqC,+CACrC,oDAAmC,2CACnC,uDAAsC,2CACtC,6DAA4C,2CAC5C,0DAAyC,2CACzC,qDAAoC,2CACpC,qDAAoC,6CAIvCtK,KAAK2E,MAAMyF,iBAAmBpK,KAAK2E,MAAM0F,mBAC1C,4BAAQ7J,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAAQ,EAAKoD,SAAS,CAACuF,kBAAmB,EAAK3F,MAAM2F,qBAAnH,0BAGPtK,KAAK2E,MAAMsF,mBAAqBjK,KAAKwW,iBAAgB,GACtD,0BAAMhW,MAAO,CAACC,QAAS,mBAEtBT,KAAK2E,MAAM3D,OAAShB,KAAK2E,MAAMyF,iBAAmB,yBAAK5J,MAAO,CAAEiB,SAAU,OAAQD,MAAO,UAAvC,gDACnD,6BACA,yBAAKhB,MAAO,CAAEiB,SAAU,SACpB,0BAAMjB,MAAO,CAAEgB,MAAO,UAAtB,4BACA,4BACIhB,MAAO,CAAEsW,WAAY,OAAQrV,SAAU,QACvCnD,MAAO0B,KAAK2E,MAAM6D,aAClBuO,SAAU,SAACtY,GACP,EAAKsG,SAAS,CAAEyD,aAAc/J,EAAMW,OAAOd,QAC3C,EAAKiK,cAAc,EAAK5D,MAAMC,KAAMnG,EAAMW,OAAOd,SAKjD0B,KAAK2E,MAAMyF,iBACX,4BAAQ9L,MAAM,WAAd,WAEJ,4BAAQA,MAAM,KAAd,KACA,4BAAQA,MAAM,KAAd,KACA,4BAAQA,MAAM,KAAd,KACA,4BAAQA,MAAM,KAAd,MAEJ,8BAOJ,6BAEI0B,KAAK2E,MAAMyF,iBACX,oCACI,4BAAQ5J,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAAQ,EAAKqV,eAA3E,YACA,4BAAQxW,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAAQ,EAAKsV,cAA3E,WACA,4BAAQzW,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAAQ,EAAKgU,kBAA3E,uBACA,4BAAQnV,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAAQ,EAAKmU,iBAA3E,kBAGR,4BAAQtV,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAAQ,EAAK4T,mBAA3E,uBACA,4BAAQ/U,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAAQ,EAAKuV,eAA3E,SAEIlX,KAAK2E,MAAMyF,iBACX,4BACI5J,MAAO,CAAEsW,WAAY,OAAQrV,SAAU,QACvCnD,MAAO0B,KAAK2E,MAAM4E,KAClBwN,SAAU,SAACtY,GAAD,OAAW,EAAKsG,SAAS,CAAEwE,KAAM9K,EAAMW,OAAOd,UAExD,4BAAQA,MAAM,cAAd,mBACA,4BAAQA,MAAM,YAAd,kBAIJ0B,KAAK2E,MAAMyF,iBACX,yBAAK5J,MAAO,CAACC,QAAS,eAAgBmF,OAAQ,OAAQ7E,OAAQ,kBAAmBoW,aAAc,MAAO1V,SAAU,OAAQsE,QAAS,QAC7H,0BAAMvF,MAAO,CAACoF,OAAQ,QAAtB,eACA,2BACIwR,KAAK,WACLC,QAASrX,KAAK2E,MAAM0F,kBACpB0M,SAAU,SAACtY,GAAD,OAAW,EAAKsG,SAAS,CAAEsF,mBAAoB,EAAK1F,MAAM0F,qBACpE7J,MAAO,CACHoF,OAAQ,OACR2Q,UAAW,eAK3B,6BACCG,IAAsB1W,KAAK2E,MAAMqF,uBAA8C,eAApBhK,KAAK2E,MAAM4E,OAA2BvJ,KAAK2E,MAAMyF,iBAAoB,oCAC7H,yBAAK5J,MAAO,CAAEgB,MAAO,QAASC,SAAU,OAAQ6V,UAAW,SAA3D,2CAC4C,6BAD5C,uCAEQtX,KAAK2E,MAAM3D,OAAU,IAAMoD,KAAK0C,IAAI,EAAG,EAAI9G,KAAK2E,MAAMoF,kBAAkBnI,QAAQ,GAAK,IAAO,YAIxG,6BACA,6BACgC,iBAA/B5B,KAAK2E,MAAMyF,iBAAsC,yBAAK5J,MAAO,CAAEiB,SAAU,OAAQD,MAAO,UAAvC,uBAAsE,+BACxF,IAA/BxB,KAAK2E,MAAMyF,iBAA4B,oCACpC,6BACKpK,KAAK8H,uBAAuB7D,KAAI,SAAC8P,EAAKtQ,GAAN,OAC7B,kBAAC,GAAD,CAAoBiC,OAAQ,EAAMqO,IAAKA,EAAK1V,IAAKoF,QAGzD,yBAAKjD,MAAO,CAACgB,MAAO,QAASC,SAAU,SAAvC,kDACmD,wCADnD,4CAC4G,6BAD5G,wBAEyB,2BAAOjB,MAAO,CAACK,MAAO,QAASvC,MAAO0B,KAAK2E,MAAM8F,yBAAgCsM,SAAU,SAAAtY,GAAK,OAAI,EAAKsG,SAAS,CAAC0F,yBAA0BhM,EAAMW,OAAOd,WAFnL,8BAGyB,2BAAOkC,MAAO,CAACK,MAAO,QAASvC,MAAO0B,KAAK2E,MAAM+F,+BAAgCqM,SAAU,SAAAtY,GAAK,OAAI,EAAKsG,SAAS,CAAC2F,+BAAgCjM,EAAMW,OAAOd,WAHzL,8BAIyB,2BAAOkC,MAAO,CAACK,MAAO,QAASvC,MAAO0B,KAAK2E,MAAMgG,wBAAgCoM,SAAU,SAAAtY,GAAK,OAAI,EAAKsG,SAAS,CAAC4F,wBAAyBlM,EAAMW,OAAOd,WAJlL,8BAKyB,2BAAOkC,MAAO,CAACK,MAAO,QAASvC,MAAO0B,KAAK2E,MAAMiG,8BAAgCmM,SAAU,SAAAtY,GAAK,OAAI,EAAKsG,SAAS,CAAC6F,8BAA+BnM,EAAMW,OAAOd,WALxL,8BAMyB,2BAAOkC,MAAO,CAACK,MAAO,QAASvC,MAAO0B,KAAK2E,MAAMkG,+BAAgCkM,SAAU,SAAAtY,GAAK,OAAI,EAAKsG,SAAS,CAAC8F,+BAAgCpM,EAAMW,OAAOd,WANzL,6BAOyB,2BAAOkC,MAAO,CAACK,MAAO,QAASvC,MAAO0B,KAAK2E,MAAMyC,kBAAgC2P,SAAU,SAAAtY,GAAK,OAAI,EAAKsG,SAAS,CAACqC,kBAAmB3I,EAAMW,OAAOd,YAE5K,yBAAKkC,MAAO,CAACoF,OAAQ,OAAQpE,MAAO,QAASC,SAAU,OAAQV,OAAQ,kBAAmBF,MAAO,QAAS0W,UAAW,OAAQ9W,QAAS,iBACjIT,KAAK2E,MAAM6F,iBAAiBvG,KAAI,SAAC4P,EAAOpQ,GACrC,IAAM+T,EAAQ3D,EAAMpY,MAAM,GAC1B,OAAO,yBAAK4C,IAAKoF,GAAV,oBACeoQ,EAAM,GAAI2D,EAAMvT,KAAI,SAAC9D,EAAGsD,GAAJ,OAAU,yCAAKtD,EAAI0T,EAAMpQ,YAGrE,6BACN,4BAAQjD,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAAQ,EAAK8V,8BAA3E,sBACA,yBAAKjX,MAAO,CAAEiB,SAAU,OAAQD,MAAO,UAAvC,iCAAgF,+BAEpF,4BAAQkW,UAAyC,IAA/B1X,KAAK2E,MAAMyF,gBAA2B5J,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAC1G,EAAKgW,2BAA0B,KADnC,gCAEwC,6BACxC,4BAAQD,UAAyC,IAA/B1X,KAAK2E,MAAMyF,gBAA2B5J,MAAO,CAAEiB,SAAU,OAAQmE,OAAQ,QAAUjE,QAAS,WAC1G,EAAKgW,2BAA0B,KADnC,4CAEoD,6BA+BpD,0BAAMnX,MAAO,CAAEgB,MAAO,UAAtB,wBAAuDxB,KAAK2E,MAAMuF,oBAAlE,MACA,yBAAK1J,MAAO,CAACC,QAAS,QAASsT,IAAK/T,KAAK6H,qB,GA3hC/B/F,IAAMC,WAkkC5B+G,SAAS8O,iBAAiB,WAlC1B,SAAgCjV,GACZ,MAAZA,EAAItE,KAA6B,OAAd6D,GACnBA,EAAU2V,wBAGE,MAAZlV,EAAItE,KAAesE,EAAImV,QACvB5V,EAAU6V,kBACQ,MAAZpV,EAAItE,KAA2B,MAAZsE,EAAItE,KAA+B,OAAd6D,GAC9CA,EAAU8U,aACE,MAAZrU,EAAItE,KAA6B,OAAd6D,GACnBA,EAAU+U,YACE,MAAZtU,EAAItE,KAA6B,OAAd6D,GACnBA,EAAUqT,iBACE,MAAZ5S,EAAItE,KAA6B,OAAd6D,GACnBA,EAAUwT,aACE,MAAZ/S,EAAItE,KAA6B,OAAd6D,GACnBA,EAAUyT,gBAEE,MAAZhT,EAAItE,KAAoC,OAArB2H,KACnBA,GAAiBgS,gBACjBrV,EAAIsV,kBAEQ,MAAZtV,EAAItE,KAAoC,OAArB2H,IACnBA,GAAiBkS,cAAc,GACnB,MAAZvV,EAAItE,KAAoC,OAArB2H,IACnBA,GAAiBkS,eAAe,GACpB,MAAZvV,EAAItE,KAAoC,OAArB2H,IACnBA,GAAiBmS,uBACL,MAAZxV,EAAItE,KAAoC,OAArB2H,IACnBA,GAAiBoS,oBACL,MAAZzV,EAAItE,KAAoC,OAArB2H,IACnBA,GAAiBqS,gB,IAsCVC,G,kLA/BPxP,SAASyP,KAAK/X,MAAMH,gBAAkB,S,+BAStC,OAAO,yBAAKG,MAAO,CACfI,UAAW,WAEX,yBAAKJ,MAAO,CAAEC,QAAS,eAAgBI,MAAO,UAC1C,wBAAIL,MAAO,CAAEgB,MAAO,UAApB,yCACA,uBAAGhB,MAAO,CAAEgB,MAAO,UAAnB,uoBAUJ,kBAAC,GAAD,MACA,0BAAMhB,MAAO,CAAEgB,MAAO,UAAtB,qDAAyF,6BACzF,0BAAMhB,MAAO,CAAEgB,MAAO,UAAW,uBAAGgX,KAAK,iDAAR,2B,GA5B3B1W,IAAMC,WC/hDJ0W,QACW,cAA7Bxa,OAAOya,SAASC,UAEe,UAA7B1a,OAAOya,SAASC,UAEhB1a,OAAOya,SAASC,SAAS9E,MACvB,2DCZN+E,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,GAAD,OAEFhQ,SAASiQ,eAAe,SDyHpB,kBAAmB7N,WACrBA,UAAU8N,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdtW,OAAM,SAAAuW,GACLtc,QAAQsc,MAAMA,EAAMC,c","file":"static/js/main.6c88db7a.chunk.js","sourcesContent":["\nlet wasm;\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetFloat64Memory0 = null;\nfunction getFloat64Memory0() {\n    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {\n        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachegetFloat64Memory0;\n}\n\nfunction passArrayF64ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 8);\n    getFloat64Memory0().set(arg, ptr / 8);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction getArrayF64FromWasm0(ptr, len) {\n    return getFloat64Memory0().subarray(ptr / 8, ptr / 8 + len);\n}\n/**\n* @param {Uint8Array} hits\n* @param {Uint8Array} misses\n* @param {number} squids_gotten\n* @param {Uint32Array} board_constraints\n* @param {Float64Array} constraint_probs\n* @returns {Float64Array | undefined}\n*/\nexport function calculate_probabilities_with_board_constraints(hits, misses, squids_gotten, board_constraints, constraint_probs) {\n    var ptr0 = passArray8ToWasm0(hits, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArray8ToWasm0(misses, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ptr2 = passArray32ToWasm0(board_constraints, wasm.__wbindgen_malloc);\n    var len2 = WASM_VECTOR_LEN;\n    var ptr3 = passArrayF64ToWasm0(constraint_probs, wasm.__wbindgen_malloc);\n    var len3 = WASM_VECTOR_LEN;\n    wasm.calculate_probabilities_with_board_constraints(8, ptr0, len0, ptr1, len1, squids_gotten, ptr2, len2, ptr3, len3);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    let v4;\n    if (r0 !== 0) {\n        v4 = getArrayF64FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 8);\n    }\n    return v4;\n}\n\n/**\n* @param {Uint8Array} hits\n* @param {Uint8Array} misses\n* @param {number} squids_gotten\n* @param {Uint32Array} observed_boards\n* @param {Uint32Array} prior_steps_from_previous_means\n* @param {Float64Array} prior_steps_from_previous_stddevs\n* @returns {Float64Array | undefined}\n*/\nexport function calculate_probabilities_from_game_history(hits, misses, squids_gotten, observed_boards, prior_steps_from_previous_means, prior_steps_from_previous_stddevs) {\n    var ptr0 = passArray8ToWasm0(hits, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArray8ToWasm0(misses, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ptr2 = passArray32ToWasm0(observed_boards, wasm.__wbindgen_malloc);\n    var len2 = WASM_VECTOR_LEN;\n    var ptr3 = passArray32ToWasm0(prior_steps_from_previous_means, wasm.__wbindgen_malloc);\n    var len3 = WASM_VECTOR_LEN;\n    var ptr4 = passArrayF64ToWasm0(prior_steps_from_previous_stddevs, wasm.__wbindgen_malloc);\n    var len4 = WASM_VECTOR_LEN;\n    wasm.calculate_probabilities_from_game_history(8, ptr0, len0, ptr1, len1, squids_gotten, ptr2, len2, ptr3, len3, ptr4, len4);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    let v5;\n    if (r0 !== 0) {\n        v5 = getArrayF64FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 8);\n    }\n    return v5;\n}\n\n/**\n* @param {Uint8Array} hits\n* @param {Uint32Array} observed_boards\n* @param {Uint32Array} prior_steps_from_previous_means\n* @param {Float64Array} prior_steps_from_previous_stddevs\n* @returns {number | undefined}\n*/\nexport function disambiguate_final_board(hits, observed_boards, prior_steps_from_previous_means, prior_steps_from_previous_stddevs) {\n    var ptr0 = passArray8ToWasm0(hits, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    var ptr1 = passArray32ToWasm0(observed_boards, wasm.__wbindgen_malloc);\n    var len1 = WASM_VECTOR_LEN;\n    var ptr2 = passArray32ToWasm0(prior_steps_from_previous_means, wasm.__wbindgen_malloc);\n    var len2 = WASM_VECTOR_LEN;\n    var ptr3 = passArrayF64ToWasm0(prior_steps_from_previous_stddevs, wasm.__wbindgen_malloc);\n    var len3 = WASM_VECTOR_LEN;\n    wasm.disambiguate_final_board(8, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    return r0 === 0 ? undefined : r1 >>> 0;\n}\n\n/**\n* @param {Uint32Array} board_table\n*/\nexport function set_board_table(board_table) {\n    var ptr0 = passArray32ToWasm0(board_table, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.set_board_table(ptr0, len0);\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nasync function init(input) {\n    //if (typeof input === 'undefined') {\n    //    input = import.meta.url.replace(/\\.js$/, '_bg.wasm');\n    //}\n    const imports = {};\n\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    const { instance, module } = await load(await input, imports);\n\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n\n    return wasm;\n}\n\nexport default init;\n\n","import React from 'react';\nimport './App.css';\nimport init, {\n    set_board_table,\n    calculate_probabilities_with_board_constraints,\n    calculate_probabilities_from_game_history,\n    disambiguate_final_board,\n} from './wasm/sploosh_wasm.js';\nconst interpolate = require('color-interpolate');\n\nvar globalDB = null;\nconst indexedDBreq = window.indexedDB.open('splooshkaboom', 1);\nindexedDBreq.onerror = function(event) {\n    alert('Failed to access IndexedDB.');\n};\n// Known issue: There's basically a race condition here in that I don't\n// wait for this onsuccess to potentially start calling dbRead.\nindexedDBreq.onsuccess = function(event) {\n    globalDB = event.target.result;\n    globalDB.onerror = function(event) {\n        alert('IndexedDB error: ' + event.target.errorCode);\n    };\n};\nindexedDBreq.onupgradeneeded = function(event) {\n    const db = event.target.result;\n    db.createObjectStore('sk');\n}\n\n// TODO: Am I using IndexedDB even remotely correctly!? This looks so weird...\n// Do I not have to somehow end or commit the transactions!?\n\nfunction dbWrite(key, value) {\n    if (globalDB === null)\n        return;\n\n    const transaction = globalDB.transaction(['sk'], 'readwrite');\n\n    transaction.oncomplete = function(event) {\n        //alert('Transaction complete!');\n    }\n    transaction.onerror = function(event) {\n        alert('Transaction error!');\n    }\n    const objectStore = transaction.objectStore('sk');\n    const request = objectStore.add(value, key);\n    request.onsuccess = function(event) {\n        //alert('Request success!');\n    }\n}\n\nfunction dbRead(key) {\n    return new Promise((resolve, reject) => {\n        const transaction = globalDB.transaction(['sk']);\n\n        transaction.oncomplete = function(event) {\n            //alert('Transaction complete!');\n        }\n        transaction.onerror = function(event) {\n            alert('Transaction error!');\n        }\n        const objectStore = transaction.objectStore('sk');\n        const request = objectStore.get(key);\n        request.onsuccess = function(event) {\n            //alert('Request success!');\n            resolve(event.target.result);\n        };\n        request.onerror = function(event) {\n            //alert('Request failure!');\n            reject();\n        };\n    });\n}\n\n//const colormap = interpolate(['#004', '#090', '#0a0', 'green']);\n//const colormap = interpolate(['#004', '#0a0', '#0d0', '#0f0', '#6f6']);\n// .        . . . .\n// 0123456789abcdef\nconst colormap = interpolate(['#004', '#070', '#090', '#0b0', '#0d0', '#0f0', '#6f6']);\nconst naturalsUpTo = (n) => [...Array(n).keys()];\n\nclass Tile extends React.Component {\n    render() {\n        const isBest = this.props.best !== null && this.props.best[0] === this.props.x && this.props.best[1] === this.props.y;\n\n        let backgroundColor = this.props.backgroundColor;\n        if (backgroundColor === undefined) {\n            backgroundColor = this.props.text === null ? colormap(this.props.prob) : (\n                this.props.text === 'HIT' ? '#a2a' : '#44a'\n            );\n        }\n\n        return <div\n            key={this.props.x + ',' + this.props.y}\n            style={{\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n                textAlign: 'center',\n                width: '70px',\n                height: '70px',\n                border: this.props.valid ? '1px solid grey' : '1px solid red',\n                outline: isBest ? '4px solid yellow' : '',\n                zIndex: isBest ? 1 : 0,\n                fontFamily: 'monospace',\n                userSelect: 'none',\n                MozUserSelect: 'none',\n                WebkitUserSelect: 'none',\n                msUserSelect: 'none',\n                color: 'white',\n                fontSize: this.props.fontSize,\n                opacity: this.props.opacity,\n                backgroundColor,\n            }}\n            onClick={this.props.onClick}\n        >\n            {this.props.text === null ? (this.props.prob * 100).toFixed(this.props.precision) + '%' : this.props.text}\n        </div>;\n    }\n}\n\nlet wasm = init(process.env.PUBLIC_URL + \"/sploosh_wasm_bg.wasm\");\n\n// Debugging value, ignore me.\nwindow.JUST_ONCE = false;\n\n// Super ugly, please forgive me. :(\nvar globalMap = null;\n\nasync function tryToProcessFrame() {\n    if (globalMap === null)\n        return;\n    if (globalMap.readyToProcess() && globalMap.state.doVideoProcessing)\n        await globalMap.readBoardState();\n}\n\nasync function globalProcessingTick() {\n    await tryToProcessFrame();\n    // We use setTimeout nested like this rather than setInterval so that the ticks\n    // don't get bunched up if the processing takes too long.\n    setTimeout(globalProcessingTick, 25);\n}\n\nasync function dbCachedFetch(url, callback) {\n    function cacheMiss() {\n        const req = new XMLHttpRequest();\n        req.open('GET', process.env.PUBLIC_URL + url, true);\n        req.responseType = 'arraybuffer';\n        req.onload = (evt) => {\n            dbWrite(url, req.response);\n            callback(req.response);\n        };\n        req.send();\n        return null;\n    }\n    const result = await dbRead(url).catch(cacheMiss);\n    if (result === undefined) {\n        cacheMiss();\n        return;\n    }\n    // This is sort of an ugly protocol, but if we hit the catch path above\n    // we signal that the callback was already called by returning null.\n    if (result === null)\n        return;\n    callback(result);\n}\n\nasync function makeBoardIndicesTable() {\n    function cacheMiss() {\n        const result = actuallyMakeBoardIndicesTable();\n        dbWrite('boardIndicesTable', result);\n        return result;\n    }\n    const result = await dbRead('boardIndicesTable').catch(cacheMiss);\n    if (result === undefined)\n        return cacheMiss();\n    return result;\n}\n\nfunction actuallyMakeBoardIndicesTable() {\n    // This convention here has to match that in the Rust component and table building C++ exactly!\n    const descs = [];\n    for (let y = 0; y < 8; y++)\n        for (let x = 0; x < 8; x++)\n            for (const direction of [false, true])\n                descs.push({x, y, direction});\n    const allBoards = [];\n    const boardIndices = {};\n    function placeSquid(board, desc, length) {\n        for (let i = 0; i < length; i++) {\n            let {x, y} = desc;\n            if (desc.direction)\n                x += i;\n            else\n                y += i;\n            const index = x + 8 * y;\n            if (x >= 8 || y >= 8)\n                return;\n            board[index] = length;\n        }\n    }\n    const board = new Array(64).fill(0);\n\n    for (const squid2 of descs) {\n        for (const squid3 of descs) {\n            for (const squid4 of descs) {\n                board.fill(0);\n                placeSquid(board, squid2, 2);\n                placeSquid(board, squid3, 3);\n                placeSquid(board, squid4, 4);\n                let count = 0;\n                for (const entry of board)\n                    count += entry\n                if (count !== 2*2 + 3*3 + 4*4)\n                    continue;\n                allBoards.push(Array.from(board));\n            }\n        }\n    }\n    let index = 0;\n    for (const board of allBoards) {\n        boardIndices[board.map((i) => i === 0 ? '.' : i).join('')] = index;\n        index++;\n    }\n    return boardIndices;\n}\n\nif (!window.JUST_ONCE) {\n    // XXX: Only re-enable this if we're re-enabling CV screen cap.\n    //globalProcessingTick();\n}\n\nfunction sampleSquid(length) {\n    const x = Math.round(Math.random() * 8);\n    const y = Math.round(Math.random() * 8);\n    const direction = Math.random() < 0.5;\n    const cells = [[x, y]];\n    for (let i = 0; i < length - 1; i++) {\n        const cell = cells[cells.length - 1];\n        const newXY = direction ? [cell[0] + 1, cell[1]] : [cell[0], cell[1] + 1];\n        cells.push(newXY);\n    }\n    return cells;\n}\n\nfunction generateLayout() {\n    const layout = {};\n    const hitLocations = {};\n    for (const n of [2, 3, 4]) {\n        while (true) {\n            const candidate = sampleSquid(n);\n            let isAdmissible = true;\n            for (const cell of candidate)\n                if (cell[0] > 7 || cell[1] > 7 || hitLocations[cell] === true)\n                    isAdmissible = false;\n            if (isAdmissible) {\n                layout['squid' + n] = candidate;\n                for (const cell of candidate)\n                    hitLocations[cell] = true;\n                break;\n            }\n        }\n    }\n    return layout;\n}\n\nclass LayoutDrawingBoard extends React.Component {\n    constructor() {\n        super();\n        this.state = { grid: this.makeEmptyGrid(), selectedCell: null };\n    }\n\n    makeEmptyGrid() {\n        const grid = [];\n        for (let y = 0; y < 8; y++)\n            for (let x = 0; x < 8; x++)\n                grid[[x, y]] = '.';\n        return grid;\n    }\n\n    clearBoard() {\n        this.setState({ grid: this.makeEmptyGrid(), selectedCell: null });\n    }\n\n    onClick(x, y) {\n        if (this.state.selectedCell === null) {\n            this.setState({ selectedCell: [x, y] });\n            return;\n        }\n        const grid = {...this.state.grid};\n        let changeMade = false;\n        for (const length of [2, 3, 4]) {\n            for (const [dx, dy] of [[+1, 0], [0, +1], [-1, 0], [0, -1]]) {\n                if (this.state.selectedCell[0] === x + dx * (length - 1) && this.state.selectedCell[1] === y + dy * (length - 1)) {\n                    // If this squid appears anywhere else, obliterate it.\n                    for (let y = 0; y < 8; y++)\n                        for (let x = 0; x < 8; x++)\n                            if (grid[[x, y]] === '' + length)\n                                grid[[x, y]] = '.';\n                    // Fill in the squid here.\n                    for (let i = 0; i < length; i++)\n                        grid[[x + i * dx, y + i * dy]] = '' + length;\n                    changeMade = true;\n                }\n            }\n        }\n        // If any squid has the wrong count, then totally eliminate it.\n        const countsBySquid = {2: 0, 3: 0, 4: 0, '.': 0};\n        for (let y = 0; y < 8; y++)\n            for (let x = 0; x < 8; x++)\n                countsBySquid[grid[[x, y]]]++;\n        for (const length of [2, 3, 4])\n            if (countsBySquid[length] !== length)\n                for (let y = 0; y < 8; y++)\n                    for (let x = 0; x < 8; x++)\n                        if (grid[[x, y]] === '' + length)\n                            grid[[x, y]] = '.';\n        if (changeMade)\n            this.setState({ grid });\n        this.setState({ selectedCell: null });\n    }\n\n    getLayoutString() {\n        // Quadratic time, but who cares?\n        let layoutString = '';\n        for (let y = 0; y < 8; y++)\n            for (let x = 0; x < 8; x++)\n                layoutString += this.state.grid[[x, y]];\n        return layoutString;\n    }\n\n    setStateFromLayoutString(layoutString) {\n        const grid = [];\n        for (let y = 0; y < 8; y++)\n            for (let x = 0; x < 8; x++)\n                grid[[x, y]] = layoutString[x + 8 * y];\n        this.setState({grid});\n    }\n\n    render() {\n        const layoutString = this.getLayoutString();\n        let boardIndex = this.props.parent.boardIndices[layoutString];\n        if (boardIndex === undefined) {\n            boardIndex = \"waiting...\";\n        }\n        const isSelectedCell = (x, y) => this.state.selectedCell !== null && x === this.state.selectedCell[0] && y === this.state.selectedCell[1];\n\n        return <div style={{\n            margin: '20px',\n            display: 'inline-block',\n            color: 'white',\n        }}>\n            <div style={{\n                backgroundImage: 'url(\"' + process.env.PUBLIC_URL + '/board_background_square.png\")',\n                backgroundSize: '100% 100%',\n                padding: '18px',\n            }}>\n                {naturalsUpTo(8).map(\n                    (y) => <div key={y} style={{\n                        display: 'flex',\n                    }}>\n                        {naturalsUpTo(8).map(\n                            (x) => <Tile\n                                key={x + ',' + y}\n                                x={x} y={y}\n                                onClick={() => this.onClick(x, y)}\n                                text={this.state.grid[[x, y]]}\n                                valid={true}\n                                best={this.state.selectedCell}\n                                fontSize={'200%'}\n                                opacity={isSelectedCell(x, y) || this.state.grid[[x, y]] !== '.' ? 0.6 : 0.2}\n                                backgroundColor={this.state.grid[[x, y]] === '.' ? undefined : 'green'}\n                            />\n                        )}\n                    </div>\n                )}\n            </div><br/>\n            Squid Layout: {boardIndex}\n        </div>;\n    }\n}\n\nvar globalBoardTimer = null;\n\nsetInterval(\n    () => {\n        if (globalBoardTimer !== null)\n            globalBoardTimer.forceUpdate();\n    },\n    69,\n);\n\nfunction renderYesNo(bool) {\n    return bool ?\n        <span style={{color: 'green', textShadow: '0px 0px 2px white'}}>YES</span> :\n        <span style={{color: 'red', textShadow: '0px 0px 2px white'}}>NO</span>;\n}\n\nclass BoardTimer extends React.Component {\n    constructor() {\n        super();\n        globalBoardTimer = this;\n        this.state = {\n            previouslyAccumulatedSeconds: 0.0,\n            //previouslyAccumulatedRupeeSeconds: 0.0,\n            timerStartMS: 0.0,\n            timerRunning: false,\n            includesLoadingTheRoom: true,\n            //rupeesCollected: false,\n            includedRewardsGotten: 0,\n            invalidated: false,\n        };\n    }\n\n    toggleRunning() {\n        const now = performance.now();\n        const elapsed = 1e-3 * (now - this.state.timerStartMS);\n        if (this.state.timerRunning)\n            this.setState({previouslyAccumulatedSeconds: this.state.previouslyAccumulatedSeconds + elapsed});\n        this.setState({timerRunning: !this.state.timerRunning, timerStartMS: now});\n    }\n\n    adjustRewards(delta) {\n        this.setState({includedRewardsGotten: Math.max(0, Math.min(2, this.state.includedRewardsGotten + delta))});\n    }\n\n    toggleLoadingTheRoom() {\n        this.setState({includesLoadingTheRoom: !this.state.includesLoadingTheRoom});\n    }\n\n    toggleInvalidated() {\n        this.setState({invalidated: !this.state.invalidated});\n    }\n\n    /*\n    toggleRupeesCollected() {\n        // TODO: Appropriately perform accumulation, then change the rate.\n        this.setState({rupeesCollected: !this.state.rupeesCollected});\n    }\n    */\n\n    resetTimer() {\n        this.setState({\n            previouslyAccumulatedSeconds: 0.0,\n            timerStartMS: performance.now(),\n            timerRunning: false,\n        });\n    }\n\n    getSecondsElapsed() {\n        let total = this.state.previouslyAccumulatedSeconds;\n        if (this.state.timerRunning) {\n            const now = performance.now();\n            total += 1e-3 * (now - this.state.timerStartMS);\n        }\n        return total;\n    }\n\n    guessStepsElapsedFromTime(timeDeltaSeconds) {\n        // I did some linear regressions from real HD Italian runs. I'll put some data up at some point.\n        let prediction = 156 + 252 * timeDeltaSeconds;\n        if (this.state.includesLoadingTheRoom)\n            prediction += -940 + Number(this.props.roomEnteredOffset);\n        prediction += this.state.includedRewardsGotten * 760;\n        return Math.round(prediction);\n    }\n\n    render() {\n        const elapsed = this.getSecondsElapsed();\n        if (this.state.invalidated)\n            return <>\n                <span style={{ fontSize: '150%', color: 'white', fontFamily: 'monospace' }}>TIMER</span>\n                <span style={{ fontSize: '150%', color: 'white', fontFamily: 'monospace' }}>INVALIDATED</span>\n            </>;\n        return <>\n            <span>&nbsp;Seconds elapsed: </span>\n            <span>&nbsp;{elapsed.toFixed(2)}&nbsp;</span>\n            <span>&nbsp;Steps:&nbsp;</span>\n            <span>&nbsp;{this.guessStepsElapsedFromTime(elapsed)}&nbsp;</span>\n            <span>&nbsp;Entered room:</span>\n            <span>&nbsp;{renderYesNo(this.state.includesLoadingTheRoom)}&nbsp;</span>\n            <span>&nbsp;Rewards gotten:&nbsp;</span>\n            <span>&nbsp;{this.state.includedRewardsGotten}&nbsp;</span>\n        </>;\n            {/* &nbsp;- Rupees collected: {renderYesNo(this.state.rupeesCollected)} */};\n    }\n}\n\nclass MainMap extends React.Component {\n    videoRef = React.createRef();\n    canvasRef = React.createRef();\n    //referenceCanvasRef = React.createRef();\n    outputCanvasRef = React.createRef();\n    hiddenAreaRef = React.createRef();\n    layoutDrawingBoardRefs = [React.createRef(), React.createRef(), React.createRef()];\n    timerRef = React.createRef();\n\n    constructor() {\n        super();\n        this.state = this.makeEmptyState();\n        this.bannerCache = new Map();\n        window.RECOMP = () => {\n            this.bannerCache = new Map();\n            this.getBoardRegistrationAndScale();\n        };\n        globalMap = this;\n        this.previouslyReadStates = [null, null, null];\n    }\n\n    componentDidMount() {\n        this.makeReferenceImageCanvases();\n        this.doComputation(this.state.grid, this.state.squidsGotten);\n        //setTimeout(() => this.getScreenRecording(), 1000);\n    }\n\n    makeReferenceImageCanvases() {\n        const hiddenArea = this.hiddenAreaRef.current;\n        this.referenceCanvases = {};\n        // 'top_banner', 'record_banner',\n        for (const name of ['hit', 'miss', 'killed_squid', 'remaining_squid', 'top_banner_new', 'bottom_banner_new']) {\n            const newCanvas = document.createElement('canvas');\n            newCanvas.setAttribute('id', 'canvas_' + name);\n            hiddenArea.appendChild(newCanvas);\n\n            const newImage = document.createElement('img');\n            newImage.src = process.env.PUBLIC_URL + '/images/' + name + '.png';\n            newImage.onload = function() {\n                newCanvas.width = this.width;\n                newCanvas.height = this.height;\n                const ctx = newCanvas.getContext('2d');\n                ctx.drawImage(newImage, 0, 0);\n            };\n            this.referenceCanvases[name] = newCanvas;\n        }\n    }\n\n    makeEmptyGrid() {\n        const grid = [];\n        for (let y = 0; y < 8; y++)\n            for (let x = 0; x < 8; x++)\n                grid[[x, y]] = null;\n        return grid;\n    }\n\n    makeEmptyState() {\n        const probs = [];\n        for (let y = 0; y < 8; y++)\n            for (let x = 0; x < 8; x++)\n                probs[[x, y]] = 0.0;\n        // Select a particular layout, for practice mode.\n        const squidLayout = generateLayout();\n        return {\n            mode: 'calculator',\n            squidLayout,\n            grid: this.makeEmptyGrid(),\n            squidsGotten: 'unknown',\n            undoBuffer: [],\n            probs,\n            best: [3, 3],\n            valid: true,\n            observationProb: 1.0,\n            screenRecordingActive: false,\n            doVideoProcessing: false,\n            lastComputationTime: -1,\n            lastCVTime: -1,\n\n            turboBlurboMode: false,\n            turboBlurboTiming: false,\n            showKeyShortcuts: false,\n\n            timerStepEstimate: null,\n\n            potentialMatches: [],\n            firstBoardStepsThousands: 500,\n            firstBoardStepsThousandsStdDev: 500,\n            nextBoardStepsThousands: 7,\n            nextBoardStepsThousandsStdDev: 3,\n            timedBoardStepsThousandsStdDev: 0.2,\n            roomEnteredOffset: 0,\n        };\n    }\n\n    async startScreenRecording() {\n        if (this.state.screenRecordingActive) {\n            alert('Already screen capturing!');\n            return;\n        }\n        const displayMediaOptions = {\n            video: {\n              cursor: \"always\",\n            },\n            audio: false,\n        };\n        const captureStream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);\n        const video = this.videoRef.current;\n        video.srcObject = captureStream;\n        video.play();\n        this.setState({screenRecordingActive: true});\n        // Ugh, super ugly. I should just wait for the video appropriately. The API gives a callback.\n        // Please forgive me, it's 5 AM where I am, and Linkus starts in ~4 hours.\n        await new Promise(resolve => setTimeout(resolve, 500));\n        this.updateCapture();\n        const canvas = this.canvasRef.current;\n        const outputCanvas = this.outputCanvasRef.current;\n        console.log(canvas, outputCanvas, canvas.width, canvas.height)\n        outputCanvas.width = canvas.width;\n        outputCanvas.height = canvas.height;\n        const ctx = outputCanvas.getContext('2d');\n        ctx.drawImage(canvas, 0, 0);\n        /*\n        setTimeout(\n            () => this.getBoardRegistrationAndScale(),\n            1000,\n        );\n        */\n    }\n\n    async initializeTurboBlurboMode(bigTable) {\n        if (this.state.turboBlurboMode !== false)\n            return;\n        this.setState({turboBlurboMode: 'initializing'});\n        this.boardIndices = await makeBoardIndicesTable();\n        this.boardIndexToLayoutString = new Array(Object.keys(this.boardIndices).length);\n        for (const key of Object.keys(this.boardIndices))\n            this.boardIndexToLayoutString[this.boardIndices[key]] = key;\n\n        const tableName = bigTable ? '/board_table_25M.bin' : '/board_table_5M.bin';\n        dbCachedFetch(tableName, (buf) => {\n            this.boardTable = new Uint32Array(buf);\n            // Warning: Do I need to await wasm here first?\n            console.log('Board table length:', this.boardTable.length);\n            // Make sure every value is in range.\n            for (const v of this.boardTable)\n                if (v > 604583)\n                    alert('BUG BUG BUG: Bad value in board table: ' + v);\n            set_board_table(this.boardTable);\n            this.setState({turboBlurboMode: true, squidsGotten: '0', mode: 'calculator'});\n        });\n    }\n\n    toggleVideoProcessing() {\n        if (!this.state.screenRecordingActive)\n            return;\n        if (this.state.doVideoProcessing === false && !this.readyToProcess()) {\n            alert('You must first detect a board.');\n            return;\n        }\n        this.setState({doVideoProcessing: !this.state.doVideoProcessing});\n        // If we have a queued up board that hasn't verified as debounced yet, just process it.\n        if (this.previouslyReadStates[this.previouslyReadStates.length - 1] !== null) {\n            const resultantState = this.previouslyReadStates[this.previouslyReadStates.length - 1];\n            this.setState(resultantState);\n            this.doComputation(resultantState.grid, resultantState.squidsGotten);\n            this.previouslyReadStates[this.previouslyReadStates.length - 1] = null;\n        }\n    }\n\n    async getBoardRegistrationAndScale() {\n        if (!this.state.screenRecordingActive)\n            return;\n        this.updateCapture();\n        let bestGuessScale = 0.25 * 1.5; //0.5;\n        let searchMargin = 0.7;\n        for (let i = 0; i < 10; i++) {\n            this.boardFitParams = await this.performGridSearch(\n                bestGuessScale * (1 - searchMargin),\n                bestGuessScale * (1 + 2 * searchMargin),\n                i === 0 ? 20 : (i === 1 ? 10 : 4),\n            );\n            bestGuessScale = this.boardFitParams.scale;\n            searchMargin /= 2;\n        }\n        console.log('Best fit params:', this.boardFitParams);\n        // Force a rerender.\n        this.bannerCache.delete(bestGuessScale);\n        this.testForTopBannerAtScale(bestGuessScale);\n        this.testForBottomBanner();\n        console.log('Final fit params:', this.boardFitParams);\n        await new Promise(resolve => setTimeout(resolve, 100));\n        this.setState({doVideoProcessing: true});\n        /*\n        setTimeout(\n            () => this.readBoardState(),\n            250,\n        )\n        //*/\n        //*\n    }\n\n    async performGridSearch(min, max, sampleCount) {\n        let bestParams = {score: -1};\n        for (let i = 0; i < sampleCount; i++) {\n            const testScale = min + i * (max - min) / (sampleCount - 1);\n            const params = this.testForTopBannerAtScale(testScale);\n            if (params.score > bestParams.score)\n                bestParams = params;\n            await new Promise(resolve => setTimeout(resolve, 10));\n        }\n        console.log(\"Grid search over:\", min, \"to\", max, \"got:\", bestParams);\n        return bestParams;\n    }\n\n    testForBottomBanner() {\n        const src = window.cv.imread('cv_canvasRef');\n\n        const base_templ = window.cv.imread('canvas_bottom_banner_new');\n        const scaled_banner_width = Math.round(base_templ.size().width * this.boardFitParams.scale);\n        const scaled_banner_height = Math.round(base_templ.size().height * this.boardFitParams.scale);\n        let templ = new window.cv.Mat();\n        let dsize = new window.cv.Size(scaled_banner_width, scaled_banner_height);\n        window.cv.resize(base_templ, templ, dsize, 0, 0, window.cv.INTER_AREA);\n\n        const dst = new window.cv.Mat();\n        const mask = new window.cv.Mat();\n        const matchMode = window.cv.TM_CCOEFF_NORMED;\n        window.cv.matchTemplate(src, templ, dst, matchMode, mask);\n        let result = window.cv.minMaxLoc(dst, mask);\n        let maxPoint = result.maxLoc;\n        let color = new window.cv.Scalar(255, 0, 0, 255);\n        let point = new window.cv.Point(maxPoint.x + templ.cols, maxPoint.y + templ.rows);\n        window.cv.rectangle(src, maxPoint, point, color, 2, window.cv.LINE_8, 0);\n        window.cv.imshow('cv_outputCanvasRef', src);\n        src.delete(); base_templ.delete(); templ.delete(); dst.delete(); mask.delete();\n        this.boardFitParams.bottomBannerOffset = {\n            x: maxPoint.x, y: maxPoint.y,\n        };\n    }\n\n    getCellXY(x, y) {\n        const bannerVerticalSpacing = this.boardFitParams.bottomBannerOffset.y - this.boardFitParams.topBannerOffset.y;\n        let aspectRatioFactor = bannerVerticalSpacing / (828 * this.boardFitParams.scale);\n        if (aspectRatioFactor < 0.95 || aspectRatioFactor > 1.05)\n            aspectRatioFactor = 1;\n\n        //const aspectRatioFactor = 1.0;\n        // Center of 0,0 cell: 161, 244\n        // Center of 1,0 cell: 240, 244\n        // Top of bottom banner: 832\n\n        //let centerX = offsetX + scale * (105.25 + x * 52.2 + window.ADJUST_X);\n        //let centerY = offsetY + scale * (155.75 + y * 52.2 + window.ADJUST_Y);\n        return {\n            x: this.boardFitParams.topBannerOffset.x + this.boardFitParams.scale * (161.5 + 75.5 * x),\n            y: this.boardFitParams.topBannerOffset.y + this.boardFitParams.scale * aspectRatioFactor * (239 + 78.6 * y),\n        };\n    }\n\n    getSquidIndicatorXY(y) {\n        const bannerVerticalSpacing = this.boardFitParams.bottomBannerOffset.y - this.boardFitParams.topBannerOffset.y;\n        let aspectRatioFactor = bannerVerticalSpacing / (828 * this.boardFitParams.scale);\n        if (aspectRatioFactor < 0.95 || aspectRatioFactor > 1.05)\n            aspectRatioFactor = 1;\n        //const aspectRatioFactor = 1.0;\n        // Center of 0,0 squid: 948, 188\n        // Center of 1,0 squid: 948, 324\n\n        return {\n            x: this.boardFitParams.topBannerOffset.x + this.boardFitParams.scale * 948,\n            y: this.boardFitParams.topBannerOffset.y + this.boardFitParams.scale * aspectRatioFactor * (185 + 133 * y),\n        };\n    }\n\n    getBoardRect() {\n        const bannerVerticalSpacing = this.boardFitParams.bottomBannerOffset.y - this.boardFitParams.topBannerOffset.y;\n        let aspectRatioFactor = bannerVerticalSpacing / (828 * this.boardFitParams.scale);\n        if (aspectRatioFactor < 0.95 || aspectRatioFactor > 1.05)\n            aspectRatioFactor = 1;\n        return new window.cv.Rect(\n            Math.round(this.boardFitParams.topBannerOffset.x), Math.round(this.boardFitParams.topBannerOffset.y),\n            Math.round(this.boardFitParams.scale * 1040),\n            Math.round(this.boardFitParams.scale * aspectRatioFactor * 940),\n        );\n    }\n\n    testForTopBannerAtScale(scale) {\n        if (this.bannerCache.has(scale)) {\n            return this.bannerCache.get(scale);\n        }\n        const src = window.cv.imread('cv_canvasRef');\n        const base_templ = window.cv.imread('canvas_top_banner_new');\n\n        const scaled_banner_width = Math.round(base_templ.size().width * scale);\n        const scaled_banner_height = Math.round(base_templ.size().height * scale);\n        let templ = new window.cv.Mat();\n        let dsize = new window.cv.Size(scaled_banner_width, scaled_banner_height);\n        window.cv.resize(base_templ, templ, dsize, 0, 0, window.cv.INTER_AREA);\n\n        const dst = new window.cv.Mat();\n        const mask = new window.cv.Mat();\n        //const matchMode = window.cv.TM_CCOEFF_NORMED;\n        const matchMode = window.cv.TM_CCOEFF_NORMED;\n        window.cv.matchTemplate(src, templ, dst, matchMode, mask);\n        let result = window.cv.minMaxLoc(dst, mask);\n        let maxPoint = result.maxLoc;\n        let color = new window.cv.Scalar(255, 0, 0, 255);\n        let point = new window.cv.Point(maxPoint.x + templ.cols, maxPoint.y + templ.rows);\n        window.cv.rectangle(src, maxPoint, point, color, 2, window.cv.LINE_8, 0);\n        window.cv.imshow('cv_outputCanvasRef', src);\n        src.delete(); base_templ.delete(); templ.delete(); dst.delete(); mask.delete();\n\n        let score = result.maxVal;\n        this.bannerCache.set(scale, score);\n        return {\n            score, scale,\n            topBannerOffset: {x: maxPoint.x, y: maxPoint.y},\n        };\n    }\n\n    readyToProcess() {\n        return this.state.screenRecordingActive &&\n            this.boardFitParams !== undefined &&\n            this.boardFitParams.hasOwnProperty('bottomBannerOffset');\n    }\n\n    async readBoardState() {\n        if (!this.readyToProcess())\n            return;\n\n        const resultantState = {\n            grid: {},\n            squidsGotten: 0,\n        };\n\n        this.updateCapture();\n        const t0 = performance.now();\n\n        const src = window.cv.imread('cv_canvasRef');\n        const ksize = new window.cv.Size(3, 3);\n        window.cv.GaussianBlur(src, src, ksize, 0, 0, window.cv.BORDER_DEFAULT);\n        const toDelete = [src];\n\n        const getPixelColor = (x, y) => {\n            const pixelPtr = src.ucharPtr(Math.round(y), Math.round(x));\n            const pixelColor = {r: pixelPtr[0], g: pixelPtr[1], b: pixelPtr[2]};\n            const energy = Math.sqrt(pixelColor.r * pixelColor.r + pixelColor.g * pixelColor.g + pixelColor.b * pixelColor.b);\n            return {...pixelColor, energy};\n        };\n\n        // Extract the info.\n        let nothingColor        = new window.cv.Scalar(80,  80,  80,  255);\n        let hitColor            = new window.cv.Scalar(255, 0,   255, 255);\n        let missColor           = new window.cv.Scalar(100, 255, 0,   255);\n        let killedSquidColor    = new window.cv.Scalar(255, 100, 100, 255);\n        let remainingSquidColor = new window.cv.Scalar(50,  255, 100, 255);\n        let mostLikelyCursorLocation = null;\n        let bestCursorScore = -1;\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                const cellXY = this.getCellXY(x, y);\n                const wayDown = getPixelColor(cellXY.x, cellXY.y + 15);\n                if (wayDown.energy > bestCursorScore) {\n                    bestCursorScore = wayDown.energy;\n                    mostLikelyCursorLocation = {x, y};\n                }\n            }\n        }\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                const cellXY = this.getCellXY(x, y);\n                const centerX = cellXY.x;\n                const centerY = cellXY.y;\n\n                // WARNING: This isn't appropriately scale insensitive.\n                const D = 2;\n                //const farD = 3;\n                const center     = getPixelColor(centerX,        centerY);\n                const upLeft     = getPixelColor(centerX - D,    centerY - D);\n                const upRight    = getPixelColor(centerX + D,    centerY - D);\n                const downLeft   = getPixelColor(centerX - D,    centerY + D);\n                const downRight  = getPixelColor(centerX + D,    centerY + D);\n                const probablyInsideCursor = x === mostLikelyCursorLocation.x && y === mostLikelyCursorLocation.y;\n                // This variable says if we think our left side is likely corrupted by the cursor's halo.\n                const cursorHaloLeft  = probablyInsideCursor || (x === mostLikelyCursorLocation.x + 1 && y === mostLikelyCursorLocation.y);\n                const cursorHaloRight = probablyInsideCursor || (x === mostLikelyCursorLocation.x - 1 && y === mostLikelyCursorLocation.y);\n                const cursorHaloUp    = probablyInsideCursor || (x === mostLikelyCursorLocation.x && y === mostLikelyCursorLocation.y + 1);\n                const cursorHaloDown  = probablyInsideCursor || (x === mostLikelyCursorLocation.x && y === mostLikelyCursorLocation.y - 1);\n                const cursorHaloUL = cursorHaloUp   || cursorHaloLeft;\n                const cursorHaloUR = cursorHaloUp   || cursorHaloRight;\n                const cursorHaloDL = cursorHaloDown || cursorHaloLeft;\n                const cursorHaloDR = cursorHaloDown || cursorHaloRight;\n                \n                let color = nothingColor;\n\n                let threshold = probablyInsideCursor ? 240 : 220;\n                const passingCount = (\n                    (center.energy    >= threshold) +\n                    (upLeft.energy    >= (cursorHaloUL ? 240 : 220)) +\n                    (upRight.energy   >= (cursorHaloUR ? 240 : 220)) +\n                    (downLeft.energy  >= (cursorHaloDL ? 240 : 220)) +\n                    (downRight.energy >= (cursorHaloDL ? 240 : 220))\n                );\n                const greenerMargin = probablyInsideCursor ? 1 : 1.02;\n                const greenerThanBlueCount = (\n                    (center.g    >= center.b *    greenerMargin) +\n                    (upLeft.g    >= upLeft.b *    (cursorHaloUL ? greenerMargin : 1.05)) +\n                    (upRight.g   >= upRight.b *   (cursorHaloUR ? greenerMargin : 1.05)) +\n                    (downLeft.g  >= downLeft.b *  (cursorHaloDL ? greenerMargin : 1.05)) +\n                    (downRight.g >= downRight.b * (cursorHaloDR ? greenerMargin : 1.05))\n                );\n                // There's an obnoxious light in this cell, so we have to special case it.\n                //const disqualified = x === 4 && y === 6 && center.energy < 200;\n                resultantState.grid[[x, y]] = null;\n                if (\n                    (passingCount >= 4 && greenerThanBlueCount >= 3) || (passingCount >= 3 && greenerThanBlueCount >= 4)\n                ) {\n                    const maxRed   = Math.max(center.r, upLeft.r, upRight.r, downLeft.r, downRight.r);\n                    const maxGreen = Math.max(center.g, upLeft.g, upRight.g, downLeft.g, downRight.g);\n                    if (maxRed > maxGreen * 1.25) {\n                        color = hitColor\n                        resultantState.grid[[x, y]] = 'HIT';\n                    } else {\n                        color = missColor;\n                        resultantState.grid[[x, y]] = 'MISS';\n                    }\n                }\n                if (window.JUST_ONCE) {\n                    // Debugging code, please ignore this.\n                    if (probablyInsideCursor)\n                        console.log('INSIDE!!!!!');\n                    console.log('Scores:', x, y, probablyInsideCursor, greenerThanBlueCount, center, upLeft, upRight, downLeft, downRight);\n                }\n                let tl = new window.cv.Point(centerX - 7, centerY - 7);\n                let br = new window.cv.Point(centerX + 7, centerY + 7);\n                window.cv.rectangle(src, tl, br, color, 1, window.cv.LINE_8, 0);\n            }\n        }\n        for (let squidIndex = 0; squidIndex < 3; squidIndex++) {\n            const cellXY = this.getSquidIndicatorXY(squidIndex);\n            const centerX = cellXY.x;\n            const centerY = cellXY.y;\n            const pixelPtr = src.ucharPtr(Math.round(centerY), Math.round(centerX));\n            const pixelColor = {r: pixelPtr[0], g: pixelPtr[1], b: pixelPtr[2]};\n            let tl = new window.cv.Point(centerX - 15, centerY - 15);\n            let br = new window.cv.Point(centerX + 15, centerY + 15);\n            let color = remainingSquidColor;\n            if (pixelColor.r > pixelColor.b * 1.25) {\n                color = killedSquidColor;\n                resultantState.squidsGotten = Math.max(resultantState.squidsGotten, squidIndex + 1);\n            }\n\n            window.cv.rectangle(src, tl, br, color, 1, window.cv.LINE_8, 0);\n        }\n        const boardRect = this.getBoardRect();\n        const srcCrop = src.roi(boardRect);\n        toDelete.push(srcCrop);\n        window.cv.imshow('cv_outputCanvasRef', srcCrop);\n        for (const mat of toDelete)\n            mat.delete();\n        const t1 = performance.now();\n        console.log('CV took: ' + (t1 - t0) + 'ms');\n        this.setState({lastCVTime: t1 - t0});\n\n        function compareStatesEqual(A, B) {\n            if (A === null || B === null)\n                return false;\n            let allEqual = A.squidsGotten  === B.squidsGotten;\n            for (let y = 0; y < 8; y++)\n                for (let x = 0; x < 8; x++)\n                    if (A.grid[[x, y]] !== B.grid[[x, y]])\n                        allEqual = false;\n            return allEqual\n        }\n\n        // Only recompute if we see states of the form: ABBB (that is, three in a row for debouncing, plus a change).\n        if (\n            (!compareStatesEqual(this.previouslyReadStates[0], this.previouslyReadStates[1])) &&\n            compareStatesEqual(this.previouslyReadStates[1], this.previouslyReadStates[2]) &&\n            compareStatesEqual(this.previouslyReadStates[2], resultantState)\n        ) {\n            this.setState(resultantState);\n            await this.doComputation(resultantState.grid, resultantState.squidsGotten);\n        }\n        this.previouslyReadStates.shift();\n        this.previouslyReadStates.push(resultantState);\n\n        return resultantState;\n    }\n\n    updateCapture() {\n        const video = this.videoRef.current;\n        const canvas = this.canvasRef.current;\n        //const referenceCanvas = this.referenceCanvasRef.current;\n        //const outputCanvas = this.outputCanvasRef.current;\n        const context = canvas.getContext('2d');\n        //const width = video.width;\n        //const height = video.height;\n        const width = 960;\n        const height = Math.round(width * (video.videoHeight / video.videoWidth));\n        console.log('Native image capture shape: ' + video.videoWidth + 'x' + video.videoHeight + ' -> scaling to: ' + width + 'x' + height);\n        canvas.width = width;\n        canvas.height = height;\n        context.drawImage(video, 0, 0, width, height);\n    }\n\n    *findMatchingLocations(observedBoards, startIndex, scanRange) {\n        if (observedBoards.length === 0) {\n            yield [];\n            return;\n        }\n        // Try to find the first match.\n        const soughtBoard = observedBoards[0];\n        const boardTable = this.boardTable;\n        const indexMax = Math.min(boardTable.length, startIndex + scanRange);\n        for (let i = startIndex; i < indexMax; i++)\n            if (boardTable[i] === soughtBoard)\n                for (const subResult of this.findMatchingLocations(observedBoards.slice(1), i, 15000))\n                    yield [i, ...subResult];\n    }\n\n    recomputePotentialMatches() {\n        const [observedBoards, _1, _2] = this.makeGameHistoryArguments();\n        const matches = [];\n        for (const match of this.findMatchingLocations(observedBoards, 0, 1000000000))\n            matches.push(match);\n        this.setState({potentialMatches: matches});\n    }\n\n    makeGameHistoryArguments() {\n        // Figure out how many history boards we have.\n        const rawObservedBoards = this.layoutDrawingBoardRefs\n            .map((ref) => this.boardIndices[ref.current.getLayoutString()]);\n        const observedBoards = [];\n        for (const ob of rawObservedBoards) {\n            if (ob === undefined)\n                break;\n            observedBoards.push(ob);\n        }\n\n        // The optimal thing to do here is to save the sequence of step delta estimates, but to make\n        // the tool less fragile we only use our timer-based estimates for the very final mean.\n\n        const priorStepsFromPreviousMeans = [];\n        const priorStepsFromPreviousStdDevs = [];\n        let first = true;\n        for (const index of [...observedBoards, null]) {\n            if (index === undefined)\n                break;\n            if (first) {\n                priorStepsFromPreviousMeans.push(1000.0 * Number(this.state.firstBoardStepsThousands));\n                priorStepsFromPreviousStdDevs.push(1000.0 * Number(this.state.firstBoardStepsThousandsStdDev));\n            } else {\n                // If we're the last delta, and also not the first, then possibly use our time delta.\n                if (index === null && this.state.timerStepEstimate !== null) {\n                    // Because the timerStepEstimate can be negative I have to avoid underflow.\n                    priorStepsFromPreviousMeans.push(Math.max(0, this.state.timerStepEstimate));\n                    priorStepsFromPreviousStdDevs.push(1000.0 * Number(this.state.timedBoardStepsThousandsStdDev));\n                } else {\n                    priorStepsFromPreviousMeans.push(1000.0 * Number(this.state.nextBoardStepsThousands));\n                    priorStepsFromPreviousStdDevs.push(1000.0 * Number(this.state.nextBoardStepsThousandsStdDev));\n                }\n            }\n            first = false;\n        }\n        return [\n            Uint32Array.from(observedBoards),\n            Uint32Array.from(priorStepsFromPreviousMeans),\n            Float64Array.from(priorStepsFromPreviousStdDevs),\n        ];\n    }\n\n    getGridStatistics(grid, squidsGotten) {\n        const hits = [];\n        const misses = [];\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                const gridValue = grid[[x, y]];\n                if (gridValue === 'HIT')\n                    hits.push(8 * y + x);\n                if (gridValue === 'MISS')\n                    misses.push(8 * y + x);\n            }\n        }\n        let numericSquidsGotten = -1;\n        for (const n of ['0', '1', '2', '3'])\n            if (squidsGotten === n || squidsGotten === Number(n))\n                numericSquidsGotten = Number(n);\n        return {hits, misses, numericSquidsGotten};\n    }\n\n    async doComputation(grid, squidsGotten) {\n        console.log('Doing computation:', squidsGotten, grid);\n        const t0 = performance.now();\n        const {hits, misses, numericSquidsGotten} = this.getGridStatistics(grid, squidsGotten);\n\n        await wasm;\n        let probabilities;\n        if (this.state.turboBlurboMode) {\n            const gameHistoryArguments = this.makeGameHistoryArguments();\n            console.log('gameHistoryArguments:', gameHistoryArguments);\n\n            probabilities = calculate_probabilities_from_game_history(\n                Uint8Array.from(hits),\n                Uint8Array.from(misses),\n                numericSquidsGotten,\n                ...gameHistoryArguments,\n            );\n        } else {\n            probabilities = calculate_probabilities_with_board_constraints(\n                Uint8Array.from(hits),\n                Uint8Array.from(misses),\n                numericSquidsGotten,\n                // No constraints for now.\n                Uint32Array.from([]),\n                Float64Array.from([]),\n            );\n        }\n\n        if (probabilities !== undefined) {\n            let maxY = 0;\n            let maxX = 0;\n            let highestProb = -1;\n            let probs = [];\n\n            // Here we implement our Manhattan distance bonus heuristic.\n            // The idea is that we want to highlight a square that isn't too far from where\n            // the player last adjusted the board. (i.e. where we believe their cursor is.)\n\n            for (let y = 0; y < 8; y++) {\n                for (let x = 0; x < 8; x++) {\n                    probs[[x, y]] = probabilities[8 * y + x];\n                    const distanceScaling = 1.0;\n                    const distanceAdjustedProb = probabilities[8 * y + x] * distanceScaling;\n                    if (grid[[x, y]] === null && distanceAdjustedProb > highestProb) {\n                        highestProb = distanceAdjustedProb;\n                        maxX = x;\n                        maxY = y;\n                    }\n                }\n            }\n            const observationProb = probabilities[64];\n            this.setState({ probs, best: highestProb >= 0 ? [maxX, maxY] : null, valid: true, observationProb });\n        } else {\n            this.setState({ valid: false });\n        }\n        const t1 = performance.now();\n        this.setState({lastComputationTime: t1 - t0});\n    }\n\n    copyToUndoBuffer() {\n        this.setState({undoBuffer: [\n            ...this.state.undoBuffer,\n            {grid: this.state.grid, squidsGotten: this.state.squidsGotten},\n        ]});\n    }\n\n    onClick(x, y, setAsHit) {\n        const grid = { ...this.state.grid };\n        let gridValue = grid[[x, y]];\n        let squidsGotten = this.state.squidsGotten;\n        this.copyToUndoBuffer();\n\n        if (this.state.mode === 'calculator') {\n            switch (gridValue) {\n                case null:\n                    gridValue = setAsHit ? 'HIT' : 'MISS';\n                    break;\n                case 'MISS':\n                    gridValue = 'HIT';\n                    break;\n                case 'HIT':\n                    gridValue = null;\n                    break;\n            }\n            grid[[x, y]] = gridValue;\n        } else {\n            // Determine from the random layout.\n            if (gridValue !== null)\n                return;\n            const arrayContains = (arr) => {\n                for (const cell of arr)\n                    if (cell[0] === x && cell[1] === y)\n                        return true;\n                return false;\n            }\n            if (arrayContains([...this.state.squidLayout.squid2, ...this.state.squidLayout.squid3, ...this.state.squidLayout.squid4])) {\n                gridValue = 'HIT';\n            } else {\n                gridValue = 'MISS';\n            }\n            grid[[x, y]] = gridValue;\n            // Compute the killed squid count.\n            squidsGotten = 0;\n            for (const n of ['2', '3', '4']) {\n                const squid = this.state.squidLayout['squid' + n];\n                let killed = true;\n                for (const cell of squid)\n                    if (grid[cell] !== 'HIT')\n                        killed = false;\n                squidsGotten += killed;\n            }\n            this.setState({ squidsGotten });\n        }\n        this.setState({ grid });\n        this.doComputation(grid, squidsGotten);\n    }\n\n    clearField() {\n        const templateState = this.makeEmptyState();\n        const newState = {};\n        for (const name of ['squidLayout', 'grid', 'squidsGotten'])\n            newState[name] = templateState[name];\n        // The squidsGotten value of 'unknown' is banned in turbo blurbo mode.\n        if (this.state.turboBlurboMode)\n            newState.squidsGotten = '0';\n        this.setState(newState);\n        this.doComputation(newState.grid, newState.squidsGotten);\n    }\n\n    undoLastMarking() {\n        const undoBuffer = [...this.state.undoBuffer];\n        if (undoBuffer.length === 0)\n            return;\n        const undoEntry = undoBuffer.pop();\n        this.setState({grid: undoEntry.grid, squidsGotten: undoEntry.squidsGotten, undoBuffer});\n        this.doComputation(undoEntry.grid, undoEntry.squidsGotten);\n    }\n\n    reportMiss() {\n        if (this.state.best !== null && this.state.grid[this.state.best] === null)\n            this.onClick(...this.state.best);\n    }\n\n    reportHit() {\n        if (this.state.best !== null && this.state.grid[this.state.best] === null)\n        {\n            this.onClick(...this.state.best, true);\n            const {hits, misses, numericSquidsGotten} = this.getGridStatistics(this.state.grid, this.state.squidsGotten);\n            if (hits.length === 9) {\n                this.incrementKills();\n            }\n        }\n    }\n\n    splitTimer() {\n        const boardTimer = this.timerRef.current;\n        if (boardTimer === null)\n            return;\n        const timerStepEstimate = boardTimer.state.invalidated ? null : boardTimer.guessStepsElapsedFromTime(boardTimer.getSecondsElapsed());\n        this.setState({timerStepEstimate});\n        console.log('Timer step estimate:', timerStepEstimate);\n        boardTimer.setState({\n            previouslyAccumulatedSeconds: 0.0,\n            timerStartMS: performance.now(),\n            // After the first split we're no longer loading the room.\n            includesLoadingTheRoom: false,\n            includedRewardsGotten: 0,\n            timerRunning: true,\n            invalidated: false,\n        });\n        this.doComputation(this.state.grid, this.state.squidsGotten);\n    }\n\n    async incrementKills() {\n        let numericValue = this.state.squidsGotten === 'unknown' ? 0 : Number(this.state.squidsGotten);\n        let grid = this.state.grid;\n        numericValue++;\n        if (numericValue === 4) {\n            // TODO: Think very carefully about this timer splitting, and if and when it should happen.\n            const gameHistoryArguments = this.makeGameHistoryArguments();\n            this.splitTimer();\n            const success = await this.copyToHistory(gameHistoryArguments);\n            if (success) {\n                numericValue = 0;\n                grid = this.makeEmptyGrid();\n            } else {\n                numericValue = 3;\n            }\n        }\n        this.copyToUndoBuffer();\n        this.setState({grid, squidsGotten: '' + numericValue});\n        this.doComputation(grid, '' + numericValue);\n    }\n\n    async copyToHistory(gameHistoryArguments) {\n        const {hits} = this.getGridStatistics(this.state.grid, this.state.squidsGotten);\n        if (gameHistoryArguments === undefined)\n            gameHistoryArguments = this.makeGameHistoryArguments();\n        await wasm;\n        const finalBoard = disambiguate_final_board(\n            Uint8Array.from(hits),\n            ...gameHistoryArguments,\n        );\n        if (finalBoard === undefined) {\n            // TODO: Show a proper error message in this case!\n            //alert('Ambiguous!');\n            return false;\n        }\n        console.log('Final board:', finalBoard);\n        const layoutString = this.boardIndexToLayoutString[finalBoard];\n        const observedBoards = gameHistoryArguments[0];\n        let fillIndex = observedBoards.length;\n        // If we're already at capacity then we have to shift the boards over.\n        if (fillIndex === this.layoutDrawingBoardRefs.length) {\n            this.shiftHistory();\n            fillIndex--;\n        }\n        this.layoutDrawingBoardRefs[fillIndex].current.setStateFromLayoutString(layoutString);\n        return true;\n    }\n\n    shiftHistory() {\n        const drawingBoards = this.layoutDrawingBoardRefs.map((ref) => ref.current);\n        for (let i = 0; i < drawingBoards.length -1; i++) {\n            drawingBoards[i].setState(drawingBoards[i + 1].state);\n        }\n        drawingBoards[drawingBoards.length - 1].clearBoard();\n    }\n\n    renderActualMap(overlayMode) {\n        return <div style={{justifySelf: 'center'}}>\n            {naturalsUpTo(8).map(\n                (y) => <div key={y} style={{\n                    display: 'flex',\n                }}>\n                    {naturalsUpTo(8).map(\n                        (x) => <Tile\n                            key={x + ',' + y}\n                            x={x} y={y}\n                            onClick={() => this.onClick(x, y)}\n                            text={this.state.grid[[x, y]]}\n                            prob={this.state.probs[[x, y]]}\n                            valid={this.state.valid}\n                            best={this.state.best}\n                            precision={overlayMode ? 0 : 2}\n                            opacity={overlayMode ? 0.5 + 0.3 * this.state.probs[[x, y]] : undefined}\n                        />\n                    )}\n                </div>\n            )}\n        </div>;\n    }\n\n    renderOverlayMap() {\n        if (!this.state.doVideoProcessing)\n            return;\n        return <div style={{\n            position: 'absolute',\n            top: '210px',\n            left: '127px',\n            transform: 'scale(1.01, 1.05)',\n            zIndex: 20,\n            display: 'inline-block',\n            /* opacity: 0.4, */\n        }}>\n            {this.renderActualMap(true)}\n        </div>;\n    }\n\n    render() {\n        let usedShots = 0;\n        let openingOptimizer = true;\n        for (let y = 0; y < 8; y++) {\n            for (let x = 0; x < 8; x++) {\n                if (this.state.grid[[x, y]] !== null) {\n                    usedShots++;\n                    if (this.state.grid[[x, y]] === 'HIT')\n                        openingOptimizer = false;\n                }\n            }\n        }\n        return <div style={{\n            margin: '20px',\n            color: 'white',\n        }}>\n            <div className=\"container\">\n                <div style={{justifySelf: \"end\", alignSelf: \"start\"}}>\n                    <div className=\"tableContainer\" style={{gridTemplateColumns: \"repeat(2, 1fr)\"}}>\n                        <span><strong>&nbsp;Item&nbsp;</strong></span>\n                        <span><strong>&nbsp;Value&nbsp;</strong></span>\n                        <span>&nbsp;Shots used:&nbsp;</span>\n                        <span>&nbsp;{usedShots}&nbsp;</span>\n                    {this.state.turboBlurboMode && this.state.turboBlurboTiming && \n                    <>\n                        <BoardTimer ref={this.timerRef} roomEnteredOffset={this.state.roomEnteredOffset} />\n                        <span>&nbsp;Last steps:&nbsp;</span>\n                        <span>&nbsp;{this.state.timerStepEstimate === null ? '-' : this.state.timerStepEstimate}&nbsp;</span>\n                    </>\n                    }\n                    {this.state.turboBlurboMode && this.state.turboBlurboTiming && this.state.showKeyShortcuts &&\n                    <>\n                        <span><strong>&nbsp;Control&nbsp;</strong></span><span><strong>&nbsp;Shortcut&nbsp;</strong></span>\n                        <span>&nbsp;Toggle Timer&nbsp;</span><span>&nbsp;Space&nbsp;</span>\n                        <span>&nbsp;Add Reward&nbsp;</span><span>&nbsp;,&nbsp;</span>\n                        <span>&nbsp;Remove Reward&nbsp;</span><span>&nbsp;&lt;&nbsp;</span>\n                        <span>&nbsp;Toggle Room Entered&nbsp;</span><span>&nbsp;m&nbsp;</span>\n                        <span>&nbsp;Invalidate Timer&nbsp;</span><span>&nbsp;;&nbsp;</span>\n                        <span>&nbsp;Reset Timer&nbsp;</span><span>&nbsp;:&nbsp;</span>\n                        <span>&nbsp;Split Timer&nbsp;</span><span>&nbsp;s&nbsp;</span>\n                    </>\n                    }\n                    </div>\n                    {this.state.turboBlurboMode && this.state.turboBlurboTiming &&\n                    <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => { this.setState({showKeyShortcuts: !this.state.showKeyShortcuts}) }}>Toggle Show Shortcuts</button>\n                    }\n                </div>\n            {this.state.doVideoProcessing || this.renderActualMap(false)}\n            <span style={{display: \"inline-block\"}}></span>\n            </div>\n            {this.state.valid || this.state.turboBlurboMode || <div style={{ fontSize: '150%', color: 'white' }}>Invalid configuration! This is not possible.</div>}\n            <br />\n            <div style={{ fontSize: '150%' }}>\n                <span style={{ color: 'white' }}>Number of squids killed:</span>\n                <select\n                    style={{ marginLeft: '20px', fontSize: '100%' }}\n                    value={this.state.squidsGotten}\n                    onChange={(event) => {\n                        this.setState({ squidsGotten: event.target.value });\n                        this.doComputation(this.state.grid, event.target.value);\n                    }}\n                >\n                    {/* In turbo blurbo mode don't allow unknown, because it's just an accident waiting to happen for a runner. */}\n                    {\n                        this.state.turboBlurboMode ||\n                        <option value=\"unknown\">Unknown</option>\n                    }\n                    <option value=\"0\">0</option>\n                    <option value=\"1\">1</option>\n                    <option value=\"2\">2</option>\n                    <option value=\"3\">3</option>\n                </select>\n                <br />\n                {/*\n                <span style={{color: 'white', fontSize: '80%'}}>\n                    Probability of this pattern yielding these results: {(100 * this.state.observationProb).toFixed(2) + '%'}\n                </span>\n                */}\n            </div>\n            <br/>\n            {\n                this.state.turboBlurboMode &&\n                <>\n                    <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => { this.reportMiss(); }}>Miss (z)</button>\n                    <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => { this.reportHit(); }}>Hit (x)</button>\n                    <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => { this.copyToHistory(); }}>Copy to History (h)</button>\n                    <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => { this.shiftHistory(); }}>Shift History</button>\n                </>\n            }\n            <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => { this.incrementKills(); }}>Increment Kills (c)</button>\n            <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => { this.clearField(); }}>Reset</button>\n            {\n                this.state.turboBlurboMode ||\n                <select\n                    style={{ marginLeft: '20px', fontSize: '150%' }}\n                    value={this.state.mode}\n                    onChange={(event) => this.setState({ mode: event.target.value })}\n                >\n                    <option value=\"calculator\">Calculator Mode</option>\n                    <option value=\"practice\">Practice Mode</option>\n                </select>\n            }\n            {\n                this.state.turboBlurboMode &&\n                <div style={{display: 'inline-block', margin: '10px', border: '1px solid white', borderRadius: '5px', fontSize: '130%', padding: '5px'}}>\n                    <span style={{margin: '5px'}}>Timer mode:</span>\n                    <input\n                        type=\"checkbox\"\n                        checked={this.state.turboBlurboTiming}\n                        onChange={(event) => this.setState({ turboBlurboTiming: !this.state.turboBlurboTiming })}\n                        style={{\n                            margin: '10px',\n                            transform: 'scale(2)',\n                        }}\n                    />\n                </div>\n            }\n            <br />\n            {openingOptimizer && (!this.state.screenRecordingActive) && this.state.mode === 'calculator' && (!this.state.turboBlurboMode) && <>\n                <div style={{ color: 'white', fontSize: '120%', marginTop: '20px' }}>\n                    Opening optimizer: Probability that this<br />pattern would get at least one hit: {\n                        this.state.valid ? ((100 * Math.max(0, 1 - this.state.observationProb)).toFixed(2) + '%') : \"Invalid\"\n                    }\n                </div>\n            </>}\n            <br/>\n            <hr/>\n            {this.state.turboBlurboMode === 'initializing' && <div style={{ fontSize: '150%', color: 'white' }}>Downloading table...<br/></div>}\n            {this.state.turboBlurboMode === true && <>\n                <div>\n                    {this.layoutDrawingBoardRefs.map((ref, i) =>\n                        <LayoutDrawingBoard parent={this} ref={ref} key={i}/>\n                    )}\n                </div>\n                <div style={{color: 'white', fontSize: '130%'}}>\n                    Gaussian RNG step count beliefs (all counts in <i>thousands</i> of steps, except \"Room entered offset\"):<br/>\n                    First board mean:    <input style={{width: '50px'}} value={this.state.firstBoardStepsThousands}       onChange={event => this.setState({firstBoardStepsThousands: event.target.value})}/> &nbsp;\n                    First board stddev:  <input style={{width: '50px'}} value={this.state.firstBoardStepsThousandsStdDev} onChange={event => this.setState({firstBoardStepsThousandsStdDev: event.target.value})}/> &nbsp;\n                    Next board mean:     <input style={{width: '50px'}} value={this.state.nextBoardStepsThousands}        onChange={event => this.setState({nextBoardStepsThousands: event.target.value})}/> &nbsp;\n                    Next board stddev:   <input style={{width: '50px'}} value={this.state.nextBoardStepsThousandsStdDev}  onChange={event => this.setState({nextBoardStepsThousandsStdDev: event.target.value})}/> &nbsp;\n                    Timed board stddev:  <input style={{width: '50px'}} value={this.state.timedBoardStepsThousandsStdDev} onChange={event => this.setState({timedBoardStepsThousandsStdDev: event.target.value})}/>&nbsp;\n                    Room entered offset: <input style={{width: '50px'}} value={this.state.roomEnteredOffset}              onChange={event => this.setState({roomEnteredOffset: event.target.value})}/>\n                </div>\n                <div style={{margin: '20px', color: 'white', fontSize: '130%', border: '1px solid white', width: '400px', minHeight: '20px', display: 'inline-block'}}>\n                    {this.state.potentialMatches.map((match, i) => {\n                        const diffs = match.slice(1);\n                        return <div key={i}>\n                            Potential match: {match[0]}{diffs.map((x, i) => <> +{x - match[i]}</>)}\n                        </div>;\n                    })}\n                </div><br/>\n                <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => { this.recomputePotentialMatches(); }}>Find Match Indices</button>\n                <div style={{ fontSize: '150%', color: 'white' }}>Turbo blurbo mode initialized.<br/></div>\n            </>}\n            <button disabled={this.state.turboBlurboMode !== false} style={{ fontSize: '150%', margin: '10px' }} onClick={() => {\n                this.initializeTurboBlurboMode(false);\n            }}>Initialize Turbo Blurbo Mode</button><br/>\n            <button disabled={this.state.turboBlurboMode !== false} style={{ fontSize: '150%', margin: '10px' }} onClick={() => {\n                this.initializeTurboBlurboMode(true);\n            }}>Initialize Turbo Blurbo Mode (big table)</button><br/>\n\n            {/*\n            <button style={{ fontSize: '150%', margin: '10px' }} onClick={() => {\n                this.startScreenRecording();\n            }}>Start Screen Cap</button>\n            <button disabled={!this.state.screenRecordingActive} style={{ fontSize: '150%', margin: '10px' }} onClick={() => {\n                this.bannerCache = new Map();\n                this.getBoardRegistrationAndScale();\n            }}>Detect Board</button>\n            <button disabled={!this.state.screenRecordingActive} style={{ fontSize: '150%', margin: '10px' }} onClick={() => {\n                this.toggleVideoProcessing();\n            }}>{this.state.doVideoProcessing ? 'Stop Processing (p)' : 'Start Processing (p)'}</button><br />\n\n            <video style={{display: 'none'}} ref={this.videoRef}>Video stream not available.</video>\n            <canvas style={{display: 'none'}} ref={this.canvasRef} id=\"cv_canvasRef\"></canvas>\n            <div style={{display: 'inline-block'}}>\n                <div style={{\n                    display: 'inline-block',\n                    position: 'relative',\n                }}>\n                    <canvas style={{\n                        border: this.state.doVideoProcessing ? '5px solid red' : '5px solid blue',\n                        width: '1000px',\n                    }} ref={this.outputCanvasRef} id=\"cv_outputCanvasRef\"></canvas>\n                    {this.renderOverlayMap()}\n                </div>\n            </div>\n            <br/>\n            */}\n            {/* <span style={{ color: 'white' }}>Last CV time: {this.state.lastCVTime}ms - Last recompute time: {this.state.lastComputationTime}ms</span> */}\n            <span style={{ color: 'white' }}>Last recompute time: {this.state.lastComputationTime}ms</span>\n            <div style={{display: 'none'}} ref={this.hiddenAreaRef}></div>\n        </div>;\n    }\n}\n\nfunction globalShortcutsHandler(evt) {\n    if (evt.key === 'p' && globalMap !== null)\n        globalMap.toggleVideoProcessing();\n\n    // Add z or y for German keyboard support.\n    if (evt.key === 'z' && evt.ctrlKey)\n        globalMap.undoLastMarking();\n    else if ((evt.key === 'z' || evt.key === 'y')  && globalMap !== null)\n        globalMap.reportMiss();\n    if (evt.key === 'x' && globalMap !== null)\n        globalMap.reportHit();\n    if (evt.key === 'c' && globalMap !== null)\n        globalMap.incrementKills();\n    if (evt.key === 's' && globalMap !== null)\n        globalMap.splitTimer();\n    if (evt.key === 'h' && globalMap !== null)\n        globalMap.copyToHistory();\n\n    if (evt.key === ' ' && globalBoardTimer !== null) {\n        globalBoardTimer.toggleRunning();\n        evt.preventDefault();\n    }\n    if (evt.key === ',' && globalBoardTimer !== null)\n        globalBoardTimer.adjustRewards(+1);\n    if (evt.key === '<' && globalBoardTimer !== null)\n        globalBoardTimer.adjustRewards(-1);\n    if (evt.key === 'm' && globalBoardTimer !== null)\n        globalBoardTimer.toggleLoadingTheRoom();\n    if (evt.key === ';' && globalBoardTimer !== null)\n        globalBoardTimer.toggleInvalidated();\n    if (evt.key === ':' && globalBoardTimer !== null)\n        globalBoardTimer.resetTimer();\n}\n\ndocument.addEventListener('keydown', globalShortcutsHandler);\n\nclass App extends React.Component {\n    componentDidMount() {\n        document.body.style.backgroundColor = '#666';\n        /*\n        const opencvScript = document.createElement('script');\n        opencvScript.addEventListener('load', )\n        opencvScript.setAttribute('src', '');\n        */\n    }\n\n    render() {\n        return <div style={{\n            textAlign: 'center',\n        }}>\n            <div style={{ display: 'inline-block', width: '600px' }}>\n                <h1 style={{ color: 'white' }}>Sploosh Kaboom Probability Calculator</h1>\n                <p style={{ color: 'white' }}>\n                    This page gives exact probabilities (no approximation) of hitting a squid in each cell, given the observation of hits, misses, and completed squid kills.\n                    Click on the map to cycle a cell between HIT and MISS.\n                    You can also set the number of squids completely killed in the drop-down menu at the bottom.\n                    You should set this to the value you see in the game for the number of squids killed.\n                    This will yield slightly more accurate probabilities.\n                    The highest probability location to play will be shown with a yellow outline.\n                    If you play perfectly according to picking the highlighted cell you will win in 20 or fewer shots ≈18.5% of the time.\n                </p>\n            </div>\n            <MainMap />\n            <span style={{ color: 'white' }}>Made by Peter Schmidt-Nielsen and CryZe (v0.0.16)</span><br/>\n            <span style={{ color: 'white' }}><a href=\"https://github.com/petersn/web-sploosh-kaboom\">GitHub Repository</a></span>\n        </div>;\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}